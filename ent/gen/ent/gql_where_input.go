// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocationproblem"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/eventfile"
	"github.com/buildbarn/bb-portal/ent/gen/ent/predicate"
	"github.com/google/uuid"
)

// BazelInvocationWhereInput represents a where input for filtering BazelInvocation queries.
type BazelInvocationWhereInput struct {
	Predicates []predicate.BazelInvocation  `json:"-"`
	Not        *BazelInvocationWhereInput   `json:"not,omitempty"`
	Or         []*BazelInvocationWhereInput `json:"or,omitempty"`
	And        []*BazelInvocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "invocation_id" field predicates.
	InvocationID      *uuid.UUID  `json:"invocationID,omitempty"`
	InvocationIDNEQ   *uuid.UUID  `json:"invocationIDNEQ,omitempty"`
	InvocationIDIn    []uuid.UUID `json:"invocationIDIn,omitempty"`
	InvocationIDNotIn []uuid.UUID `json:"invocationIDNotIn,omitempty"`
	InvocationIDGT    *uuid.UUID  `json:"invocationIDGT,omitempty"`
	InvocationIDGTE   *uuid.UUID  `json:"invocationIDGTE,omitempty"`
	InvocationIDLT    *uuid.UUID  `json:"invocationIDLT,omitempty"`
	InvocationIDLTE   *uuid.UUID  `json:"invocationIDLTE,omitempty"`

	// "started_at" field predicates.
	StartedAt      *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ   *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT    *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE   *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT    *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE   *time.Time  `json:"startedAtLTE,omitempty"`

	// "ended_at" field predicates.
	EndedAt       *time.Time  `json:"endedAt,omitempty"`
	EndedAtNEQ    *time.Time  `json:"endedAtNEQ,omitempty"`
	EndedAtIn     []time.Time `json:"endedAtIn,omitempty"`
	EndedAtNotIn  []time.Time `json:"endedAtNotIn,omitempty"`
	EndedAtGT     *time.Time  `json:"endedAtGT,omitempty"`
	EndedAtGTE    *time.Time  `json:"endedAtGTE,omitempty"`
	EndedAtLT     *time.Time  `json:"endedAtLT,omitempty"`
	EndedAtLTE    *time.Time  `json:"endedAtLTE,omitempty"`
	EndedAtIsNil  bool        `json:"endedAtIsNil,omitempty"`
	EndedAtNotNil bool        `json:"endedAtNotNil,omitempty"`

	// "change_number" field predicates.
	ChangeNumber       *int32  `json:"changeNumber,omitempty"`
	ChangeNumberNEQ    *int32  `json:"changeNumberNEQ,omitempty"`
	ChangeNumberIn     []int32 `json:"changeNumberIn,omitempty"`
	ChangeNumberNotIn  []int32 `json:"changeNumberNotIn,omitempty"`
	ChangeNumberGT     *int32  `json:"changeNumberGT,omitempty"`
	ChangeNumberGTE    *int32  `json:"changeNumberGTE,omitempty"`
	ChangeNumberLT     *int32  `json:"changeNumberLT,omitempty"`
	ChangeNumberLTE    *int32  `json:"changeNumberLTE,omitempty"`
	ChangeNumberIsNil  bool    `json:"changeNumberIsNil,omitempty"`
	ChangeNumberNotNil bool    `json:"changeNumberNotNil,omitempty"`

	// "patchset_number" field predicates.
	PatchsetNumber       *int32  `json:"patchsetNumber,omitempty"`
	PatchsetNumberNEQ    *int32  `json:"patchsetNumberNEQ,omitempty"`
	PatchsetNumberIn     []int32 `json:"patchsetNumberIn,omitempty"`
	PatchsetNumberNotIn  []int32 `json:"patchsetNumberNotIn,omitempty"`
	PatchsetNumberGT     *int32  `json:"patchsetNumberGT,omitempty"`
	PatchsetNumberGTE    *int32  `json:"patchsetNumberGTE,omitempty"`
	PatchsetNumberLT     *int32  `json:"patchsetNumberLT,omitempty"`
	PatchsetNumberLTE    *int32  `json:"patchsetNumberLTE,omitempty"`
	PatchsetNumberIsNil  bool    `json:"patchsetNumberIsNil,omitempty"`
	PatchsetNumberNotNil bool    `json:"patchsetNumberNotNil,omitempty"`

	// "bep_completed" field predicates.
	BepCompleted       *bool `json:"bepCompleted,omitempty"`
	BepCompletedNEQ    *bool `json:"bepCompletedNEQ,omitempty"`
	BepCompletedIsNil  bool  `json:"bepCompletedIsNil,omitempty"`
	BepCompletedNotNil bool  `json:"bepCompletedNotNil,omitempty"`

	// "step_label" field predicates.
	StepLabel             *string  `json:"stepLabel,omitempty"`
	StepLabelNEQ          *string  `json:"stepLabelNEQ,omitempty"`
	StepLabelIn           []string `json:"stepLabelIn,omitempty"`
	StepLabelNotIn        []string `json:"stepLabelNotIn,omitempty"`
	StepLabelGT           *string  `json:"stepLabelGT,omitempty"`
	StepLabelGTE          *string  `json:"stepLabelGTE,omitempty"`
	StepLabelLT           *string  `json:"stepLabelLT,omitempty"`
	StepLabelLTE          *string  `json:"stepLabelLTE,omitempty"`
	StepLabelContains     *string  `json:"stepLabelContains,omitempty"`
	StepLabelHasPrefix    *string  `json:"stepLabelHasPrefix,omitempty"`
	StepLabelHasSuffix    *string  `json:"stepLabelHasSuffix,omitempty"`
	StepLabelEqualFold    *string  `json:"stepLabelEqualFold,omitempty"`
	StepLabelContainsFold *string  `json:"stepLabelContainsFold,omitempty"`

	// "user_email" field predicates.
	UserEmail             *string  `json:"userEmail,omitempty"`
	UserEmailNEQ          *string  `json:"userEmailNEQ,omitempty"`
	UserEmailIn           []string `json:"userEmailIn,omitempty"`
	UserEmailNotIn        []string `json:"userEmailNotIn,omitempty"`
	UserEmailGT           *string  `json:"userEmailGT,omitempty"`
	UserEmailGTE          *string  `json:"userEmailGTE,omitempty"`
	UserEmailLT           *string  `json:"userEmailLT,omitempty"`
	UserEmailLTE          *string  `json:"userEmailLTE,omitempty"`
	UserEmailContains     *string  `json:"userEmailContains,omitempty"`
	UserEmailHasPrefix    *string  `json:"userEmailHasPrefix,omitempty"`
	UserEmailHasSuffix    *string  `json:"userEmailHasSuffix,omitempty"`
	UserEmailIsNil        bool     `json:"userEmailIsNil,omitempty"`
	UserEmailNotNil       bool     `json:"userEmailNotNil,omitempty"`
	UserEmailEqualFold    *string  `json:"userEmailEqualFold,omitempty"`
	UserEmailContainsFold *string  `json:"userEmailContainsFold,omitempty"`

	// "user_ldap" field predicates.
	UserLdap             *string  `json:"userLdap,omitempty"`
	UserLdapNEQ          *string  `json:"userLdapNEQ,omitempty"`
	UserLdapIn           []string `json:"userLdapIn,omitempty"`
	UserLdapNotIn        []string `json:"userLdapNotIn,omitempty"`
	UserLdapGT           *string  `json:"userLdapGT,omitempty"`
	UserLdapGTE          *string  `json:"userLdapGTE,omitempty"`
	UserLdapLT           *string  `json:"userLdapLT,omitempty"`
	UserLdapLTE          *string  `json:"userLdapLTE,omitempty"`
	UserLdapContains     *string  `json:"userLdapContains,omitempty"`
	UserLdapHasPrefix    *string  `json:"userLdapHasPrefix,omitempty"`
	UserLdapHasSuffix    *string  `json:"userLdapHasSuffix,omitempty"`
	UserLdapIsNil        bool     `json:"userLdapIsNil,omitempty"`
	UserLdapNotNil       bool     `json:"userLdapNotNil,omitempty"`
	UserLdapEqualFold    *string  `json:"userLdapEqualFold,omitempty"`
	UserLdapContainsFold *string  `json:"userLdapContainsFold,omitempty"`

	// "event_file" edge predicates.
	HasEventFile     *bool                  `json:"hasEventFile,omitempty"`
	HasEventFileWith []*EventFileWhereInput `json:"hasEventFileWith,omitempty"`

	// "build" edge predicates.
	HasBuild     *bool              `json:"hasBuild,omitempty"`
	HasBuildWith []*BuildWhereInput `json:"hasBuildWith,omitempty"`

	// "problems" edge predicates.
	HasProblems     *bool                               `json:"hasProblems,omitempty"`
	HasProblemsWith []*BazelInvocationProblemWhereInput `json:"hasProblemsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BazelInvocationWhereInput) AddPredicates(predicates ...predicate.BazelInvocation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BazelInvocationWhereInput filter on the BazelInvocationQuery builder.
func (i *BazelInvocationWhereInput) Filter(q *BazelInvocationQuery) (*BazelInvocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBazelInvocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBazelInvocationWhereInput is returned in case the BazelInvocationWhereInput is empty.
var ErrEmptyBazelInvocationWhereInput = errors.New("ent: empty predicate BazelInvocationWhereInput")

// P returns a predicate for filtering bazelinvocations.
// An error is returned if the input is empty or invalid.
func (i *BazelInvocationWhereInput) P() (predicate.BazelInvocation, error) {
	var predicates []predicate.BazelInvocation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bazelinvocation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BazelInvocation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bazelinvocation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BazelInvocation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bazelinvocation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bazelinvocation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bazelinvocation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bazelinvocation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bazelinvocation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bazelinvocation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bazelinvocation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bazelinvocation.IDLTE(*i.IDLTE))
	}
	if i.InvocationID != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDEQ(*i.InvocationID))
	}
	if i.InvocationIDNEQ != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDNEQ(*i.InvocationIDNEQ))
	}
	if len(i.InvocationIDIn) > 0 {
		predicates = append(predicates, bazelinvocation.InvocationIDIn(i.InvocationIDIn...))
	}
	if len(i.InvocationIDNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.InvocationIDNotIn(i.InvocationIDNotIn...))
	}
	if i.InvocationIDGT != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDGT(*i.InvocationIDGT))
	}
	if i.InvocationIDGTE != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDGTE(*i.InvocationIDGTE))
	}
	if i.InvocationIDLT != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDLT(*i.InvocationIDLT))
	}
	if i.InvocationIDLTE != nil {
		predicates = append(predicates, bazelinvocation.InvocationIDLTE(*i.InvocationIDLTE))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, bazelinvocation.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, bazelinvocation.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, bazelinvocation.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, bazelinvocation.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, bazelinvocation.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, bazelinvocation.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, bazelinvocation.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.EndedAt != nil {
		predicates = append(predicates, bazelinvocation.EndedAtEQ(*i.EndedAt))
	}
	if i.EndedAtNEQ != nil {
		predicates = append(predicates, bazelinvocation.EndedAtNEQ(*i.EndedAtNEQ))
	}
	if len(i.EndedAtIn) > 0 {
		predicates = append(predicates, bazelinvocation.EndedAtIn(i.EndedAtIn...))
	}
	if len(i.EndedAtNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.EndedAtNotIn(i.EndedAtNotIn...))
	}
	if i.EndedAtGT != nil {
		predicates = append(predicates, bazelinvocation.EndedAtGT(*i.EndedAtGT))
	}
	if i.EndedAtGTE != nil {
		predicates = append(predicates, bazelinvocation.EndedAtGTE(*i.EndedAtGTE))
	}
	if i.EndedAtLT != nil {
		predicates = append(predicates, bazelinvocation.EndedAtLT(*i.EndedAtLT))
	}
	if i.EndedAtLTE != nil {
		predicates = append(predicates, bazelinvocation.EndedAtLTE(*i.EndedAtLTE))
	}
	if i.EndedAtIsNil {
		predicates = append(predicates, bazelinvocation.EndedAtIsNil())
	}
	if i.EndedAtNotNil {
		predicates = append(predicates, bazelinvocation.EndedAtNotNil())
	}
	if i.ChangeNumber != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberEQ(*i.ChangeNumber))
	}
	if i.ChangeNumberNEQ != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberNEQ(*i.ChangeNumberNEQ))
	}
	if len(i.ChangeNumberIn) > 0 {
		predicates = append(predicates, bazelinvocation.ChangeNumberIn(i.ChangeNumberIn...))
	}
	if len(i.ChangeNumberNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.ChangeNumberNotIn(i.ChangeNumberNotIn...))
	}
	if i.ChangeNumberGT != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberGT(*i.ChangeNumberGT))
	}
	if i.ChangeNumberGTE != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberGTE(*i.ChangeNumberGTE))
	}
	if i.ChangeNumberLT != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberLT(*i.ChangeNumberLT))
	}
	if i.ChangeNumberLTE != nil {
		predicates = append(predicates, bazelinvocation.ChangeNumberLTE(*i.ChangeNumberLTE))
	}
	if i.ChangeNumberIsNil {
		predicates = append(predicates, bazelinvocation.ChangeNumberIsNil())
	}
	if i.ChangeNumberNotNil {
		predicates = append(predicates, bazelinvocation.ChangeNumberNotNil())
	}
	if i.PatchsetNumber != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberEQ(*i.PatchsetNumber))
	}
	if i.PatchsetNumberNEQ != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNEQ(*i.PatchsetNumberNEQ))
	}
	if len(i.PatchsetNumberIn) > 0 {
		predicates = append(predicates, bazelinvocation.PatchsetNumberIn(i.PatchsetNumberIn...))
	}
	if len(i.PatchsetNumberNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNotIn(i.PatchsetNumberNotIn...))
	}
	if i.PatchsetNumberGT != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberGT(*i.PatchsetNumberGT))
	}
	if i.PatchsetNumberGTE != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberGTE(*i.PatchsetNumberGTE))
	}
	if i.PatchsetNumberLT != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberLT(*i.PatchsetNumberLT))
	}
	if i.PatchsetNumberLTE != nil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberLTE(*i.PatchsetNumberLTE))
	}
	if i.PatchsetNumberIsNil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberIsNil())
	}
	if i.PatchsetNumberNotNil {
		predicates = append(predicates, bazelinvocation.PatchsetNumberNotNil())
	}
	if i.BepCompleted != nil {
		predicates = append(predicates, bazelinvocation.BepCompletedEQ(*i.BepCompleted))
	}
	if i.BepCompletedNEQ != nil {
		predicates = append(predicates, bazelinvocation.BepCompletedNEQ(*i.BepCompletedNEQ))
	}
	if i.BepCompletedIsNil {
		predicates = append(predicates, bazelinvocation.BepCompletedIsNil())
	}
	if i.BepCompletedNotNil {
		predicates = append(predicates, bazelinvocation.BepCompletedNotNil())
	}
	if i.StepLabel != nil {
		predicates = append(predicates, bazelinvocation.StepLabelEQ(*i.StepLabel))
	}
	if i.StepLabelNEQ != nil {
		predicates = append(predicates, bazelinvocation.StepLabelNEQ(*i.StepLabelNEQ))
	}
	if len(i.StepLabelIn) > 0 {
		predicates = append(predicates, bazelinvocation.StepLabelIn(i.StepLabelIn...))
	}
	if len(i.StepLabelNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.StepLabelNotIn(i.StepLabelNotIn...))
	}
	if i.StepLabelGT != nil {
		predicates = append(predicates, bazelinvocation.StepLabelGT(*i.StepLabelGT))
	}
	if i.StepLabelGTE != nil {
		predicates = append(predicates, bazelinvocation.StepLabelGTE(*i.StepLabelGTE))
	}
	if i.StepLabelLT != nil {
		predicates = append(predicates, bazelinvocation.StepLabelLT(*i.StepLabelLT))
	}
	if i.StepLabelLTE != nil {
		predicates = append(predicates, bazelinvocation.StepLabelLTE(*i.StepLabelLTE))
	}
	if i.StepLabelContains != nil {
		predicates = append(predicates, bazelinvocation.StepLabelContains(*i.StepLabelContains))
	}
	if i.StepLabelHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.StepLabelHasPrefix(*i.StepLabelHasPrefix))
	}
	if i.StepLabelHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.StepLabelHasSuffix(*i.StepLabelHasSuffix))
	}
	if i.StepLabelEqualFold != nil {
		predicates = append(predicates, bazelinvocation.StepLabelEqualFold(*i.StepLabelEqualFold))
	}
	if i.StepLabelContainsFold != nil {
		predicates = append(predicates, bazelinvocation.StepLabelContainsFold(*i.StepLabelContainsFold))
	}
	if i.UserEmail != nil {
		predicates = append(predicates, bazelinvocation.UserEmailEQ(*i.UserEmail))
	}
	if i.UserEmailNEQ != nil {
		predicates = append(predicates, bazelinvocation.UserEmailNEQ(*i.UserEmailNEQ))
	}
	if len(i.UserEmailIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserEmailIn(i.UserEmailIn...))
	}
	if len(i.UserEmailNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserEmailNotIn(i.UserEmailNotIn...))
	}
	if i.UserEmailGT != nil {
		predicates = append(predicates, bazelinvocation.UserEmailGT(*i.UserEmailGT))
	}
	if i.UserEmailGTE != nil {
		predicates = append(predicates, bazelinvocation.UserEmailGTE(*i.UserEmailGTE))
	}
	if i.UserEmailLT != nil {
		predicates = append(predicates, bazelinvocation.UserEmailLT(*i.UserEmailLT))
	}
	if i.UserEmailLTE != nil {
		predicates = append(predicates, bazelinvocation.UserEmailLTE(*i.UserEmailLTE))
	}
	if i.UserEmailContains != nil {
		predicates = append(predicates, bazelinvocation.UserEmailContains(*i.UserEmailContains))
	}
	if i.UserEmailHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.UserEmailHasPrefix(*i.UserEmailHasPrefix))
	}
	if i.UserEmailHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.UserEmailHasSuffix(*i.UserEmailHasSuffix))
	}
	if i.UserEmailIsNil {
		predicates = append(predicates, bazelinvocation.UserEmailIsNil())
	}
	if i.UserEmailNotNil {
		predicates = append(predicates, bazelinvocation.UserEmailNotNil())
	}
	if i.UserEmailEqualFold != nil {
		predicates = append(predicates, bazelinvocation.UserEmailEqualFold(*i.UserEmailEqualFold))
	}
	if i.UserEmailContainsFold != nil {
		predicates = append(predicates, bazelinvocation.UserEmailContainsFold(*i.UserEmailContainsFold))
	}
	if i.UserLdap != nil {
		predicates = append(predicates, bazelinvocation.UserLdapEQ(*i.UserLdap))
	}
	if i.UserLdapNEQ != nil {
		predicates = append(predicates, bazelinvocation.UserLdapNEQ(*i.UserLdapNEQ))
	}
	if len(i.UserLdapIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserLdapIn(i.UserLdapIn...))
	}
	if len(i.UserLdapNotIn) > 0 {
		predicates = append(predicates, bazelinvocation.UserLdapNotIn(i.UserLdapNotIn...))
	}
	if i.UserLdapGT != nil {
		predicates = append(predicates, bazelinvocation.UserLdapGT(*i.UserLdapGT))
	}
	if i.UserLdapGTE != nil {
		predicates = append(predicates, bazelinvocation.UserLdapGTE(*i.UserLdapGTE))
	}
	if i.UserLdapLT != nil {
		predicates = append(predicates, bazelinvocation.UserLdapLT(*i.UserLdapLT))
	}
	if i.UserLdapLTE != nil {
		predicates = append(predicates, bazelinvocation.UserLdapLTE(*i.UserLdapLTE))
	}
	if i.UserLdapContains != nil {
		predicates = append(predicates, bazelinvocation.UserLdapContains(*i.UserLdapContains))
	}
	if i.UserLdapHasPrefix != nil {
		predicates = append(predicates, bazelinvocation.UserLdapHasPrefix(*i.UserLdapHasPrefix))
	}
	if i.UserLdapHasSuffix != nil {
		predicates = append(predicates, bazelinvocation.UserLdapHasSuffix(*i.UserLdapHasSuffix))
	}
	if i.UserLdapIsNil {
		predicates = append(predicates, bazelinvocation.UserLdapIsNil())
	}
	if i.UserLdapNotNil {
		predicates = append(predicates, bazelinvocation.UserLdapNotNil())
	}
	if i.UserLdapEqualFold != nil {
		predicates = append(predicates, bazelinvocation.UserLdapEqualFold(*i.UserLdapEqualFold))
	}
	if i.UserLdapContainsFold != nil {
		predicates = append(predicates, bazelinvocation.UserLdapContainsFold(*i.UserLdapContainsFold))
	}

	if i.HasEventFile != nil {
		p := bazelinvocation.HasEventFile()
		if !*i.HasEventFile {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventFileWith) > 0 {
		with := make([]predicate.EventFile, 0, len(i.HasEventFileWith))
		for _, w := range i.HasEventFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasEventFileWith(with...))
	}
	if i.HasBuild != nil {
		p := bazelinvocation.HasBuild()
		if !*i.HasBuild {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildWith) > 0 {
		with := make([]predicate.Build, 0, len(i.HasBuildWith))
		for _, w := range i.HasBuildWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasBuildWith(with...))
	}
	if i.HasProblems != nil {
		p := bazelinvocation.HasProblems()
		if !*i.HasProblems {
			p = bazelinvocation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProblemsWith) > 0 {
		with := make([]predicate.BazelInvocationProblem, 0, len(i.HasProblemsWith))
		for _, w := range i.HasProblemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProblemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocation.HasProblemsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBazelInvocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bazelinvocation.And(predicates...), nil
	}
}

// BazelInvocationProblemWhereInput represents a where input for filtering BazelInvocationProblem queries.
type BazelInvocationProblemWhereInput struct {
	Predicates []predicate.BazelInvocationProblem  `json:"-"`
	Not        *BazelInvocationProblemWhereInput   `json:"not,omitempty"`
	Or         []*BazelInvocationProblemWhereInput `json:"or,omitempty"`
	And        []*BazelInvocationProblemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "problem_type" field predicates.
	ProblemType             *string  `json:"problemType,omitempty"`
	ProblemTypeNEQ          *string  `json:"problemTypeNEQ,omitempty"`
	ProblemTypeIn           []string `json:"problemTypeIn,omitempty"`
	ProblemTypeNotIn        []string `json:"problemTypeNotIn,omitempty"`
	ProblemTypeGT           *string  `json:"problemTypeGT,omitempty"`
	ProblemTypeGTE          *string  `json:"problemTypeGTE,omitempty"`
	ProblemTypeLT           *string  `json:"problemTypeLT,omitempty"`
	ProblemTypeLTE          *string  `json:"problemTypeLTE,omitempty"`
	ProblemTypeContains     *string  `json:"problemTypeContains,omitempty"`
	ProblemTypeHasPrefix    *string  `json:"problemTypeHasPrefix,omitempty"`
	ProblemTypeHasSuffix    *string  `json:"problemTypeHasSuffix,omitempty"`
	ProblemTypeEqualFold    *string  `json:"problemTypeEqualFold,omitempty"`
	ProblemTypeContainsFold *string  `json:"problemTypeContainsFold,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BazelInvocationProblemWhereInput) AddPredicates(predicates ...predicate.BazelInvocationProblem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BazelInvocationProblemWhereInput filter on the BazelInvocationProblemQuery builder.
func (i *BazelInvocationProblemWhereInput) Filter(q *BazelInvocationProblemQuery) (*BazelInvocationProblemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBazelInvocationProblemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBazelInvocationProblemWhereInput is returned in case the BazelInvocationProblemWhereInput is empty.
var ErrEmptyBazelInvocationProblemWhereInput = errors.New("ent: empty predicate BazelInvocationProblemWhereInput")

// P returns a predicate for filtering bazelinvocationproblems.
// An error is returned if the input is empty or invalid.
func (i *BazelInvocationProblemWhereInput) P() (predicate.BazelInvocationProblem, error) {
	var predicates []predicate.BazelInvocationProblem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bazelinvocationproblem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BazelInvocationProblem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bazelinvocationproblem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BazelInvocationProblem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bazelinvocationproblem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bazelinvocationproblem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bazelinvocationproblem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bazelinvocationproblem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bazelinvocationproblem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bazelinvocationproblem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bazelinvocationproblem.IDLTE(*i.IDLTE))
	}
	if i.ProblemType != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeEQ(*i.ProblemType))
	}
	if i.ProblemTypeNEQ != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeNEQ(*i.ProblemTypeNEQ))
	}
	if len(i.ProblemTypeIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeIn(i.ProblemTypeIn...))
	}
	if len(i.ProblemTypeNotIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeNotIn(i.ProblemTypeNotIn...))
	}
	if i.ProblemTypeGT != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeGT(*i.ProblemTypeGT))
	}
	if i.ProblemTypeGTE != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeGTE(*i.ProblemTypeGTE))
	}
	if i.ProblemTypeLT != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeLT(*i.ProblemTypeLT))
	}
	if i.ProblemTypeLTE != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeLTE(*i.ProblemTypeLTE))
	}
	if i.ProblemTypeContains != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeContains(*i.ProblemTypeContains))
	}
	if i.ProblemTypeHasPrefix != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeHasPrefix(*i.ProblemTypeHasPrefix))
	}
	if i.ProblemTypeHasSuffix != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeHasSuffix(*i.ProblemTypeHasSuffix))
	}
	if i.ProblemTypeEqualFold != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeEqualFold(*i.ProblemTypeEqualFold))
	}
	if i.ProblemTypeContainsFold != nil {
		predicates = append(predicates, bazelinvocationproblem.ProblemTypeContainsFold(*i.ProblemTypeContainsFold))
	}
	if i.Label != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, bazelinvocationproblem.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, bazelinvocationproblem.LabelContainsFold(*i.LabelContainsFold))
	}

	if i.HasBazelInvocation != nil {
		p := bazelinvocationproblem.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = bazelinvocationproblem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bazelinvocationproblem.HasBazelInvocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBazelInvocationProblemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bazelinvocationproblem.And(predicates...), nil
	}
}

// BlobWhereInput represents a where input for filtering Blob queries.
type BlobWhereInput struct {
	Predicates []predicate.Blob  `json:"-"`
	Not        *BlobWhereInput   `json:"not,omitempty"`
	Or         []*BlobWhereInput `json:"or,omitempty"`
	And        []*BlobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "uri" field predicates.
	URI             *string  `json:"uri,omitempty"`
	URINEQ          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGT           *string  `json:"uriGT,omitempty"`
	URIGTE          *string  `json:"uriGTE,omitempty"`
	URILT           *string  `json:"uriLT,omitempty"`
	URILTE          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`

	// "size_bytes" field predicates.
	SizeBytes       *int64  `json:"sizeBytes,omitempty"`
	SizeBytesNEQ    *int64  `json:"sizeBytesNEQ,omitempty"`
	SizeBytesIn     []int64 `json:"sizeBytesIn,omitempty"`
	SizeBytesNotIn  []int64 `json:"sizeBytesNotIn,omitempty"`
	SizeBytesGT     *int64  `json:"sizeBytesGT,omitempty"`
	SizeBytesGTE    *int64  `json:"sizeBytesGTE,omitempty"`
	SizeBytesLT     *int64  `json:"sizeBytesLT,omitempty"`
	SizeBytesLTE    *int64  `json:"sizeBytesLTE,omitempty"`
	SizeBytesIsNil  bool    `json:"sizeBytesIsNil,omitempty"`
	SizeBytesNotNil bool    `json:"sizeBytesNotNil,omitempty"`

	// "archiving_status" field predicates.
	ArchivingStatus      *blob.ArchivingStatus  `json:"archivingStatus,omitempty"`
	ArchivingStatusNEQ   *blob.ArchivingStatus  `json:"archivingStatusNEQ,omitempty"`
	ArchivingStatusIn    []blob.ArchivingStatus `json:"archivingStatusIn,omitempty"`
	ArchivingStatusNotIn []blob.ArchivingStatus `json:"archivingStatusNotIn,omitempty"`

	// "reason" field predicates.
	Reason             *string  `json:"reason,omitempty"`
	ReasonNEQ          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGT           *string  `json:"reasonGT,omitempty"`
	ReasonGTE          *string  `json:"reasonGTE,omitempty"`
	ReasonLT           *string  `json:"reasonLT,omitempty"`
	ReasonLTE          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonIsNil        bool     `json:"reasonIsNil,omitempty"`
	ReasonNotNil       bool     `json:"reasonNotNil,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`

	// "archive_url" field predicates.
	ArchiveURL             *string  `json:"archiveURL,omitempty"`
	ArchiveURLNEQ          *string  `json:"archiveURLNEQ,omitempty"`
	ArchiveURLIn           []string `json:"archiveURLIn,omitempty"`
	ArchiveURLNotIn        []string `json:"archiveURLNotIn,omitempty"`
	ArchiveURLGT           *string  `json:"archiveURLGT,omitempty"`
	ArchiveURLGTE          *string  `json:"archiveURLGTE,omitempty"`
	ArchiveURLLT           *string  `json:"archiveURLLT,omitempty"`
	ArchiveURLLTE          *string  `json:"archiveURLLTE,omitempty"`
	ArchiveURLContains     *string  `json:"archiveURLContains,omitempty"`
	ArchiveURLHasPrefix    *string  `json:"archiveURLHasPrefix,omitempty"`
	ArchiveURLHasSuffix    *string  `json:"archiveURLHasSuffix,omitempty"`
	ArchiveURLIsNil        bool     `json:"archiveURLIsNil,omitempty"`
	ArchiveURLNotNil       bool     `json:"archiveURLNotNil,omitempty"`
	ArchiveURLEqualFold    *string  `json:"archiveURLEqualFold,omitempty"`
	ArchiveURLContainsFold *string  `json:"archiveURLContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BlobWhereInput) AddPredicates(predicates ...predicate.Blob) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BlobWhereInput filter on the BlobQuery builder.
func (i *BlobWhereInput) Filter(q *BlobQuery) (*BlobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBlobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBlobWhereInput is returned in case the BlobWhereInput is empty.
var ErrEmptyBlobWhereInput = errors.New("ent: empty predicate BlobWhereInput")

// P returns a predicate for filtering blobs.
// An error is returned if the input is empty or invalid.
func (i *BlobWhereInput) P() (predicate.Blob, error) {
	var predicates []predicate.Blob
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, blob.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Blob, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, blob.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Blob, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, blob.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, blob.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, blob.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, blob.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, blob.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, blob.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, blob.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, blob.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, blob.IDLTE(*i.IDLTE))
	}
	if i.URI != nil {
		predicates = append(predicates, blob.URIEQ(*i.URI))
	}
	if i.URINEQ != nil {
		predicates = append(predicates, blob.URINEQ(*i.URINEQ))
	}
	if len(i.URIIn) > 0 {
		predicates = append(predicates, blob.URIIn(i.URIIn...))
	}
	if len(i.URINotIn) > 0 {
		predicates = append(predicates, blob.URINotIn(i.URINotIn...))
	}
	if i.URIGT != nil {
		predicates = append(predicates, blob.URIGT(*i.URIGT))
	}
	if i.URIGTE != nil {
		predicates = append(predicates, blob.URIGTE(*i.URIGTE))
	}
	if i.URILT != nil {
		predicates = append(predicates, blob.URILT(*i.URILT))
	}
	if i.URILTE != nil {
		predicates = append(predicates, blob.URILTE(*i.URILTE))
	}
	if i.URIContains != nil {
		predicates = append(predicates, blob.URIContains(*i.URIContains))
	}
	if i.URIHasPrefix != nil {
		predicates = append(predicates, blob.URIHasPrefix(*i.URIHasPrefix))
	}
	if i.URIHasSuffix != nil {
		predicates = append(predicates, blob.URIHasSuffix(*i.URIHasSuffix))
	}
	if i.URIEqualFold != nil {
		predicates = append(predicates, blob.URIEqualFold(*i.URIEqualFold))
	}
	if i.URIContainsFold != nil {
		predicates = append(predicates, blob.URIContainsFold(*i.URIContainsFold))
	}
	if i.SizeBytes != nil {
		predicates = append(predicates, blob.SizeBytesEQ(*i.SizeBytes))
	}
	if i.SizeBytesNEQ != nil {
		predicates = append(predicates, blob.SizeBytesNEQ(*i.SizeBytesNEQ))
	}
	if len(i.SizeBytesIn) > 0 {
		predicates = append(predicates, blob.SizeBytesIn(i.SizeBytesIn...))
	}
	if len(i.SizeBytesNotIn) > 0 {
		predicates = append(predicates, blob.SizeBytesNotIn(i.SizeBytesNotIn...))
	}
	if i.SizeBytesGT != nil {
		predicates = append(predicates, blob.SizeBytesGT(*i.SizeBytesGT))
	}
	if i.SizeBytesGTE != nil {
		predicates = append(predicates, blob.SizeBytesGTE(*i.SizeBytesGTE))
	}
	if i.SizeBytesLT != nil {
		predicates = append(predicates, blob.SizeBytesLT(*i.SizeBytesLT))
	}
	if i.SizeBytesLTE != nil {
		predicates = append(predicates, blob.SizeBytesLTE(*i.SizeBytesLTE))
	}
	if i.SizeBytesIsNil {
		predicates = append(predicates, blob.SizeBytesIsNil())
	}
	if i.SizeBytesNotNil {
		predicates = append(predicates, blob.SizeBytesNotNil())
	}
	if i.ArchivingStatus != nil {
		predicates = append(predicates, blob.ArchivingStatusEQ(*i.ArchivingStatus))
	}
	if i.ArchivingStatusNEQ != nil {
		predicates = append(predicates, blob.ArchivingStatusNEQ(*i.ArchivingStatusNEQ))
	}
	if len(i.ArchivingStatusIn) > 0 {
		predicates = append(predicates, blob.ArchivingStatusIn(i.ArchivingStatusIn...))
	}
	if len(i.ArchivingStatusNotIn) > 0 {
		predicates = append(predicates, blob.ArchivingStatusNotIn(i.ArchivingStatusNotIn...))
	}
	if i.Reason != nil {
		predicates = append(predicates, blob.ReasonEQ(*i.Reason))
	}
	if i.ReasonNEQ != nil {
		predicates = append(predicates, blob.ReasonNEQ(*i.ReasonNEQ))
	}
	if len(i.ReasonIn) > 0 {
		predicates = append(predicates, blob.ReasonIn(i.ReasonIn...))
	}
	if len(i.ReasonNotIn) > 0 {
		predicates = append(predicates, blob.ReasonNotIn(i.ReasonNotIn...))
	}
	if i.ReasonGT != nil {
		predicates = append(predicates, blob.ReasonGT(*i.ReasonGT))
	}
	if i.ReasonGTE != nil {
		predicates = append(predicates, blob.ReasonGTE(*i.ReasonGTE))
	}
	if i.ReasonLT != nil {
		predicates = append(predicates, blob.ReasonLT(*i.ReasonLT))
	}
	if i.ReasonLTE != nil {
		predicates = append(predicates, blob.ReasonLTE(*i.ReasonLTE))
	}
	if i.ReasonContains != nil {
		predicates = append(predicates, blob.ReasonContains(*i.ReasonContains))
	}
	if i.ReasonHasPrefix != nil {
		predicates = append(predicates, blob.ReasonHasPrefix(*i.ReasonHasPrefix))
	}
	if i.ReasonHasSuffix != nil {
		predicates = append(predicates, blob.ReasonHasSuffix(*i.ReasonHasSuffix))
	}
	if i.ReasonIsNil {
		predicates = append(predicates, blob.ReasonIsNil())
	}
	if i.ReasonNotNil {
		predicates = append(predicates, blob.ReasonNotNil())
	}
	if i.ReasonEqualFold != nil {
		predicates = append(predicates, blob.ReasonEqualFold(*i.ReasonEqualFold))
	}
	if i.ReasonContainsFold != nil {
		predicates = append(predicates, blob.ReasonContainsFold(*i.ReasonContainsFold))
	}
	if i.ArchiveURL != nil {
		predicates = append(predicates, blob.ArchiveURLEQ(*i.ArchiveURL))
	}
	if i.ArchiveURLNEQ != nil {
		predicates = append(predicates, blob.ArchiveURLNEQ(*i.ArchiveURLNEQ))
	}
	if len(i.ArchiveURLIn) > 0 {
		predicates = append(predicates, blob.ArchiveURLIn(i.ArchiveURLIn...))
	}
	if len(i.ArchiveURLNotIn) > 0 {
		predicates = append(predicates, blob.ArchiveURLNotIn(i.ArchiveURLNotIn...))
	}
	if i.ArchiveURLGT != nil {
		predicates = append(predicates, blob.ArchiveURLGT(*i.ArchiveURLGT))
	}
	if i.ArchiveURLGTE != nil {
		predicates = append(predicates, blob.ArchiveURLGTE(*i.ArchiveURLGTE))
	}
	if i.ArchiveURLLT != nil {
		predicates = append(predicates, blob.ArchiveURLLT(*i.ArchiveURLLT))
	}
	if i.ArchiveURLLTE != nil {
		predicates = append(predicates, blob.ArchiveURLLTE(*i.ArchiveURLLTE))
	}
	if i.ArchiveURLContains != nil {
		predicates = append(predicates, blob.ArchiveURLContains(*i.ArchiveURLContains))
	}
	if i.ArchiveURLHasPrefix != nil {
		predicates = append(predicates, blob.ArchiveURLHasPrefix(*i.ArchiveURLHasPrefix))
	}
	if i.ArchiveURLHasSuffix != nil {
		predicates = append(predicates, blob.ArchiveURLHasSuffix(*i.ArchiveURLHasSuffix))
	}
	if i.ArchiveURLIsNil {
		predicates = append(predicates, blob.ArchiveURLIsNil())
	}
	if i.ArchiveURLNotNil {
		predicates = append(predicates, blob.ArchiveURLNotNil())
	}
	if i.ArchiveURLEqualFold != nil {
		predicates = append(predicates, blob.ArchiveURLEqualFold(*i.ArchiveURLEqualFold))
	}
	if i.ArchiveURLContainsFold != nil {
		predicates = append(predicates, blob.ArchiveURLContainsFold(*i.ArchiveURLContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBlobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return blob.And(predicates...), nil
	}
}

// BuildWhereInput represents a where input for filtering Build queries.
type BuildWhereInput struct {
	Predicates []predicate.Build  `json:"-"`
	Not        *BuildWhereInput   `json:"not,omitempty"`
	Or         []*BuildWhereInput `json:"or,omitempty"`
	And        []*BuildWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "build_url" field predicates.
	BuildURL             *string  `json:"buildURL,omitempty"`
	BuildURLNEQ          *string  `json:"buildURLNEQ,omitempty"`
	BuildURLIn           []string `json:"buildURLIn,omitempty"`
	BuildURLNotIn        []string `json:"buildURLNotIn,omitempty"`
	BuildURLGT           *string  `json:"buildURLGT,omitempty"`
	BuildURLGTE          *string  `json:"buildURLGTE,omitempty"`
	BuildURLLT           *string  `json:"buildURLLT,omitempty"`
	BuildURLLTE          *string  `json:"buildURLLTE,omitempty"`
	BuildURLContains     *string  `json:"buildURLContains,omitempty"`
	BuildURLHasPrefix    *string  `json:"buildURLHasPrefix,omitempty"`
	BuildURLHasSuffix    *string  `json:"buildURLHasSuffix,omitempty"`
	BuildURLEqualFold    *string  `json:"buildURLEqualFold,omitempty"`
	BuildURLContainsFold *string  `json:"buildURLContainsFold,omitempty"`

	// "build_uuid" field predicates.
	BuildUUID      *uuid.UUID  `json:"buildUUID,omitempty"`
	BuildUUIDNEQ   *uuid.UUID  `json:"buildUUIDNEQ,omitempty"`
	BuildUUIDIn    []uuid.UUID `json:"buildUUIDIn,omitempty"`
	BuildUUIDNotIn []uuid.UUID `json:"buildUUIDNotIn,omitempty"`
	BuildUUIDGT    *uuid.UUID  `json:"buildUUIDGT,omitempty"`
	BuildUUIDGTE   *uuid.UUID  `json:"buildUUIDGTE,omitempty"`
	BuildUUIDLT    *uuid.UUID  `json:"buildUUIDLT,omitempty"`
	BuildUUIDLTE   *uuid.UUID  `json:"buildUUIDLTE,omitempty"`

	// "invocations" edge predicates.
	HasInvocations     *bool                        `json:"hasInvocations,omitempty"`
	HasInvocationsWith []*BazelInvocationWhereInput `json:"hasInvocationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuildWhereInput) AddPredicates(predicates ...predicate.Build) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuildWhereInput filter on the BuildQuery builder.
func (i *BuildWhereInput) Filter(q *BuildQuery) (*BuildQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuildWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuildWhereInput is returned in case the BuildWhereInput is empty.
var ErrEmptyBuildWhereInput = errors.New("ent: empty predicate BuildWhereInput")

// P returns a predicate for filtering builds.
// An error is returned if the input is empty or invalid.
func (i *BuildWhereInput) P() (predicate.Build, error) {
	var predicates []predicate.Build
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, build.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Build, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, build.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Build, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, build.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, build.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, build.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, build.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, build.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, build.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, build.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, build.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, build.IDLTE(*i.IDLTE))
	}
	if i.BuildURL != nil {
		predicates = append(predicates, build.BuildURLEQ(*i.BuildURL))
	}
	if i.BuildURLNEQ != nil {
		predicates = append(predicates, build.BuildURLNEQ(*i.BuildURLNEQ))
	}
	if len(i.BuildURLIn) > 0 {
		predicates = append(predicates, build.BuildURLIn(i.BuildURLIn...))
	}
	if len(i.BuildURLNotIn) > 0 {
		predicates = append(predicates, build.BuildURLNotIn(i.BuildURLNotIn...))
	}
	if i.BuildURLGT != nil {
		predicates = append(predicates, build.BuildURLGT(*i.BuildURLGT))
	}
	if i.BuildURLGTE != nil {
		predicates = append(predicates, build.BuildURLGTE(*i.BuildURLGTE))
	}
	if i.BuildURLLT != nil {
		predicates = append(predicates, build.BuildURLLT(*i.BuildURLLT))
	}
	if i.BuildURLLTE != nil {
		predicates = append(predicates, build.BuildURLLTE(*i.BuildURLLTE))
	}
	if i.BuildURLContains != nil {
		predicates = append(predicates, build.BuildURLContains(*i.BuildURLContains))
	}
	if i.BuildURLHasPrefix != nil {
		predicates = append(predicates, build.BuildURLHasPrefix(*i.BuildURLHasPrefix))
	}
	if i.BuildURLHasSuffix != nil {
		predicates = append(predicates, build.BuildURLHasSuffix(*i.BuildURLHasSuffix))
	}
	if i.BuildURLEqualFold != nil {
		predicates = append(predicates, build.BuildURLEqualFold(*i.BuildURLEqualFold))
	}
	if i.BuildURLContainsFold != nil {
		predicates = append(predicates, build.BuildURLContainsFold(*i.BuildURLContainsFold))
	}
	if i.BuildUUID != nil {
		predicates = append(predicates, build.BuildUUIDEQ(*i.BuildUUID))
	}
	if i.BuildUUIDNEQ != nil {
		predicates = append(predicates, build.BuildUUIDNEQ(*i.BuildUUIDNEQ))
	}
	if len(i.BuildUUIDIn) > 0 {
		predicates = append(predicates, build.BuildUUIDIn(i.BuildUUIDIn...))
	}
	if len(i.BuildUUIDNotIn) > 0 {
		predicates = append(predicates, build.BuildUUIDNotIn(i.BuildUUIDNotIn...))
	}
	if i.BuildUUIDGT != nil {
		predicates = append(predicates, build.BuildUUIDGT(*i.BuildUUIDGT))
	}
	if i.BuildUUIDGTE != nil {
		predicates = append(predicates, build.BuildUUIDGTE(*i.BuildUUIDGTE))
	}
	if i.BuildUUIDLT != nil {
		predicates = append(predicates, build.BuildUUIDLT(*i.BuildUUIDLT))
	}
	if i.BuildUUIDLTE != nil {
		predicates = append(predicates, build.BuildUUIDLTE(*i.BuildUUIDLTE))
	}

	if i.HasInvocations != nil {
		p := build.HasInvocations()
		if !*i.HasInvocations {
			p = build.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInvocationsWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasInvocationsWith))
		for _, w := range i.HasInvocationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInvocationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, build.HasInvocationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuildWhereInput
	case 1:
		return predicates[0], nil
	default:
		return build.And(predicates...), nil
	}
}

// EventFileWhereInput represents a where input for filtering EventFile queries.
type EventFileWhereInput struct {
	Predicates []predicate.EventFile  `json:"-"`
	Not        *EventFileWhereInput   `json:"not,omitempty"`
	Or         []*EventFileWhereInput `json:"or,omitempty"`
	And        []*EventFileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "mod_time" field predicates.
	ModTime      *time.Time  `json:"modTime,omitempty"`
	ModTimeNEQ   *time.Time  `json:"modTimeNEQ,omitempty"`
	ModTimeIn    []time.Time `json:"modTimeIn,omitempty"`
	ModTimeNotIn []time.Time `json:"modTimeNotIn,omitempty"`
	ModTimeGT    *time.Time  `json:"modTimeGT,omitempty"`
	ModTimeGTE   *time.Time  `json:"modTimeGTE,omitempty"`
	ModTimeLT    *time.Time  `json:"modTimeLT,omitempty"`
	ModTimeLTE   *time.Time  `json:"modTimeLTE,omitempty"`

	// "protocol" field predicates.
	Protocol             *string  `json:"protocol,omitempty"`
	ProtocolNEQ          *string  `json:"protocolNEQ,omitempty"`
	ProtocolIn           []string `json:"protocolIn,omitempty"`
	ProtocolNotIn        []string `json:"protocolNotIn,omitempty"`
	ProtocolGT           *string  `json:"protocolGT,omitempty"`
	ProtocolGTE          *string  `json:"protocolGTE,omitempty"`
	ProtocolLT           *string  `json:"protocolLT,omitempty"`
	ProtocolLTE          *string  `json:"protocolLTE,omitempty"`
	ProtocolContains     *string  `json:"protocolContains,omitempty"`
	ProtocolHasPrefix    *string  `json:"protocolHasPrefix,omitempty"`
	ProtocolHasSuffix    *string  `json:"protocolHasSuffix,omitempty"`
	ProtocolEqualFold    *string  `json:"protocolEqualFold,omitempty"`
	ProtocolContainsFold *string  `json:"protocolContainsFold,omitempty"`

	// "mime_type" field predicates.
	MimeType             *string  `json:"mimeType,omitempty"`
	MimeTypeNEQ          *string  `json:"mimeTypeNEQ,omitempty"`
	MimeTypeIn           []string `json:"mimeTypeIn,omitempty"`
	MimeTypeNotIn        []string `json:"mimeTypeNotIn,omitempty"`
	MimeTypeGT           *string  `json:"mimeTypeGT,omitempty"`
	MimeTypeGTE          *string  `json:"mimeTypeGTE,omitempty"`
	MimeTypeLT           *string  `json:"mimeTypeLT,omitempty"`
	MimeTypeLTE          *string  `json:"mimeTypeLTE,omitempty"`
	MimeTypeContains     *string  `json:"mimeTypeContains,omitempty"`
	MimeTypeHasPrefix    *string  `json:"mimeTypeHasPrefix,omitempty"`
	MimeTypeHasSuffix    *string  `json:"mimeTypeHasSuffix,omitempty"`
	MimeTypeEqualFold    *string  `json:"mimeTypeEqualFold,omitempty"`
	MimeTypeContainsFold *string  `json:"mimeTypeContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "reason" field predicates.
	Reason             *string  `json:"reason,omitempty"`
	ReasonNEQ          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGT           *string  `json:"reasonGT,omitempty"`
	ReasonGTE          *string  `json:"reasonGTE,omitempty"`
	ReasonLT           *string  `json:"reasonLT,omitempty"`
	ReasonLTE          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonIsNil        bool     `json:"reasonIsNil,omitempty"`
	ReasonNotNil       bool     `json:"reasonNotNil,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`

	// "bazel_invocation" edge predicates.
	HasBazelInvocation     *bool                        `json:"hasBazelInvocation,omitempty"`
	HasBazelInvocationWith []*BazelInvocationWhereInput `json:"hasBazelInvocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EventFileWhereInput) AddPredicates(predicates ...predicate.EventFile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EventFileWhereInput filter on the EventFileQuery builder.
func (i *EventFileWhereInput) Filter(q *EventFileQuery) (*EventFileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEventFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEventFileWhereInput is returned in case the EventFileWhereInput is empty.
var ErrEmptyEventFileWhereInput = errors.New("ent: empty predicate EventFileWhereInput")

// P returns a predicate for filtering eventfiles.
// An error is returned if the input is empty or invalid.
func (i *EventFileWhereInput) P() (predicate.EventFile, error) {
	var predicates []predicate.EventFile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, eventfile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EventFile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, eventfile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EventFile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, eventfile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, eventfile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, eventfile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, eventfile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, eventfile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, eventfile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, eventfile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, eventfile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, eventfile.IDLTE(*i.IDLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, eventfile.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, eventfile.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, eventfile.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, eventfile.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, eventfile.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, eventfile.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, eventfile.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, eventfile.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, eventfile.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, eventfile.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, eventfile.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, eventfile.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, eventfile.URLContainsFold(*i.URLContainsFold))
	}
	if i.ModTime != nil {
		predicates = append(predicates, eventfile.ModTimeEQ(*i.ModTime))
	}
	if i.ModTimeNEQ != nil {
		predicates = append(predicates, eventfile.ModTimeNEQ(*i.ModTimeNEQ))
	}
	if len(i.ModTimeIn) > 0 {
		predicates = append(predicates, eventfile.ModTimeIn(i.ModTimeIn...))
	}
	if len(i.ModTimeNotIn) > 0 {
		predicates = append(predicates, eventfile.ModTimeNotIn(i.ModTimeNotIn...))
	}
	if i.ModTimeGT != nil {
		predicates = append(predicates, eventfile.ModTimeGT(*i.ModTimeGT))
	}
	if i.ModTimeGTE != nil {
		predicates = append(predicates, eventfile.ModTimeGTE(*i.ModTimeGTE))
	}
	if i.ModTimeLT != nil {
		predicates = append(predicates, eventfile.ModTimeLT(*i.ModTimeLT))
	}
	if i.ModTimeLTE != nil {
		predicates = append(predicates, eventfile.ModTimeLTE(*i.ModTimeLTE))
	}
	if i.Protocol != nil {
		predicates = append(predicates, eventfile.ProtocolEQ(*i.Protocol))
	}
	if i.ProtocolNEQ != nil {
		predicates = append(predicates, eventfile.ProtocolNEQ(*i.ProtocolNEQ))
	}
	if len(i.ProtocolIn) > 0 {
		predicates = append(predicates, eventfile.ProtocolIn(i.ProtocolIn...))
	}
	if len(i.ProtocolNotIn) > 0 {
		predicates = append(predicates, eventfile.ProtocolNotIn(i.ProtocolNotIn...))
	}
	if i.ProtocolGT != nil {
		predicates = append(predicates, eventfile.ProtocolGT(*i.ProtocolGT))
	}
	if i.ProtocolGTE != nil {
		predicates = append(predicates, eventfile.ProtocolGTE(*i.ProtocolGTE))
	}
	if i.ProtocolLT != nil {
		predicates = append(predicates, eventfile.ProtocolLT(*i.ProtocolLT))
	}
	if i.ProtocolLTE != nil {
		predicates = append(predicates, eventfile.ProtocolLTE(*i.ProtocolLTE))
	}
	if i.ProtocolContains != nil {
		predicates = append(predicates, eventfile.ProtocolContains(*i.ProtocolContains))
	}
	if i.ProtocolHasPrefix != nil {
		predicates = append(predicates, eventfile.ProtocolHasPrefix(*i.ProtocolHasPrefix))
	}
	if i.ProtocolHasSuffix != nil {
		predicates = append(predicates, eventfile.ProtocolHasSuffix(*i.ProtocolHasSuffix))
	}
	if i.ProtocolEqualFold != nil {
		predicates = append(predicates, eventfile.ProtocolEqualFold(*i.ProtocolEqualFold))
	}
	if i.ProtocolContainsFold != nil {
		predicates = append(predicates, eventfile.ProtocolContainsFold(*i.ProtocolContainsFold))
	}
	if i.MimeType != nil {
		predicates = append(predicates, eventfile.MimeTypeEQ(*i.MimeType))
	}
	if i.MimeTypeNEQ != nil {
		predicates = append(predicates, eventfile.MimeTypeNEQ(*i.MimeTypeNEQ))
	}
	if len(i.MimeTypeIn) > 0 {
		predicates = append(predicates, eventfile.MimeTypeIn(i.MimeTypeIn...))
	}
	if len(i.MimeTypeNotIn) > 0 {
		predicates = append(predicates, eventfile.MimeTypeNotIn(i.MimeTypeNotIn...))
	}
	if i.MimeTypeGT != nil {
		predicates = append(predicates, eventfile.MimeTypeGT(*i.MimeTypeGT))
	}
	if i.MimeTypeGTE != nil {
		predicates = append(predicates, eventfile.MimeTypeGTE(*i.MimeTypeGTE))
	}
	if i.MimeTypeLT != nil {
		predicates = append(predicates, eventfile.MimeTypeLT(*i.MimeTypeLT))
	}
	if i.MimeTypeLTE != nil {
		predicates = append(predicates, eventfile.MimeTypeLTE(*i.MimeTypeLTE))
	}
	if i.MimeTypeContains != nil {
		predicates = append(predicates, eventfile.MimeTypeContains(*i.MimeTypeContains))
	}
	if i.MimeTypeHasPrefix != nil {
		predicates = append(predicates, eventfile.MimeTypeHasPrefix(*i.MimeTypeHasPrefix))
	}
	if i.MimeTypeHasSuffix != nil {
		predicates = append(predicates, eventfile.MimeTypeHasSuffix(*i.MimeTypeHasSuffix))
	}
	if i.MimeTypeEqualFold != nil {
		predicates = append(predicates, eventfile.MimeTypeEqualFold(*i.MimeTypeEqualFold))
	}
	if i.MimeTypeContainsFold != nil {
		predicates = append(predicates, eventfile.MimeTypeContainsFold(*i.MimeTypeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, eventfile.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, eventfile.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, eventfile.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, eventfile.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, eventfile.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, eventfile.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, eventfile.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, eventfile.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, eventfile.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, eventfile.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, eventfile.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, eventfile.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, eventfile.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Reason != nil {
		predicates = append(predicates, eventfile.ReasonEQ(*i.Reason))
	}
	if i.ReasonNEQ != nil {
		predicates = append(predicates, eventfile.ReasonNEQ(*i.ReasonNEQ))
	}
	if len(i.ReasonIn) > 0 {
		predicates = append(predicates, eventfile.ReasonIn(i.ReasonIn...))
	}
	if len(i.ReasonNotIn) > 0 {
		predicates = append(predicates, eventfile.ReasonNotIn(i.ReasonNotIn...))
	}
	if i.ReasonGT != nil {
		predicates = append(predicates, eventfile.ReasonGT(*i.ReasonGT))
	}
	if i.ReasonGTE != nil {
		predicates = append(predicates, eventfile.ReasonGTE(*i.ReasonGTE))
	}
	if i.ReasonLT != nil {
		predicates = append(predicates, eventfile.ReasonLT(*i.ReasonLT))
	}
	if i.ReasonLTE != nil {
		predicates = append(predicates, eventfile.ReasonLTE(*i.ReasonLTE))
	}
	if i.ReasonContains != nil {
		predicates = append(predicates, eventfile.ReasonContains(*i.ReasonContains))
	}
	if i.ReasonHasPrefix != nil {
		predicates = append(predicates, eventfile.ReasonHasPrefix(*i.ReasonHasPrefix))
	}
	if i.ReasonHasSuffix != nil {
		predicates = append(predicates, eventfile.ReasonHasSuffix(*i.ReasonHasSuffix))
	}
	if i.ReasonIsNil {
		predicates = append(predicates, eventfile.ReasonIsNil())
	}
	if i.ReasonNotNil {
		predicates = append(predicates, eventfile.ReasonNotNil())
	}
	if i.ReasonEqualFold != nil {
		predicates = append(predicates, eventfile.ReasonEqualFold(*i.ReasonEqualFold))
	}
	if i.ReasonContainsFold != nil {
		predicates = append(predicates, eventfile.ReasonContainsFold(*i.ReasonContainsFold))
	}

	if i.HasBazelInvocation != nil {
		p := eventfile.HasBazelInvocation()
		if !*i.HasBazelInvocation {
			p = eventfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBazelInvocationWith) > 0 {
		with := make([]predicate.BazelInvocation, 0, len(i.HasBazelInvocationWith))
		for _, w := range i.HasBazelInvocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBazelInvocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, eventfile.HasBazelInvocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEventFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return eventfile.And(predicates...), nil
	}
}
