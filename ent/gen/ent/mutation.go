// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocation"
	"github.com/buildbarn/bb-portal/ent/gen/ent/bazelinvocationproblem"
	"github.com/buildbarn/bb-portal/ent/gen/ent/blob"
	"github.com/buildbarn/bb-portal/ent/gen/ent/build"
	"github.com/buildbarn/bb-portal/ent/gen/ent/eventfile"
	"github.com/buildbarn/bb-portal/ent/gen/ent/predicate"
	"github.com/buildbarn/bb-portal/pkg/summary"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBazelInvocation        = "BazelInvocation"
	TypeBazelInvocationProblem = "BazelInvocationProblem"
	TypeBlob                   = "Blob"
	TypeBuild                  = "Build"
	TypeEventFile              = "EventFile"
)

// BazelInvocationMutation represents an operation that mutates the BazelInvocation nodes in the graph.
type BazelInvocationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	invocation_id      *uuid.UUID
	started_at         *time.Time
	ended_at           *time.Time
	change_number      *int32
	addchange_number   *int32
	patchset_number    *int32
	addpatchset_number *int32
	summary            *summary.InvocationSummary
	bep_completed      *bool
	step_label         *string
	related_files      *map[string]string
	user_email         *string
	user_ldap          *string
	clearedFields      map[string]struct{}
	event_file         *int
	clearedevent_file  bool
	build              *int
	clearedbuild       bool
	problems           map[int]struct{}
	removedproblems    map[int]struct{}
	clearedproblems    bool
	done               bool
	oldValue           func(context.Context) (*BazelInvocation, error)
	predicates         []predicate.BazelInvocation
}

var _ ent.Mutation = (*BazelInvocationMutation)(nil)

// bazelinvocationOption allows management of the mutation configuration using functional options.
type bazelinvocationOption func(*BazelInvocationMutation)

// newBazelInvocationMutation creates new mutation for the BazelInvocation entity.
func newBazelInvocationMutation(c config, op Op, opts ...bazelinvocationOption) *BazelInvocationMutation {
	m := &BazelInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeBazelInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBazelInvocationID sets the ID field of the mutation.
func withBazelInvocationID(id int) bazelinvocationOption {
	return func(m *BazelInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *BazelInvocation
		)
		m.oldValue = func(ctx context.Context) (*BazelInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BazelInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBazelInvocation sets the old BazelInvocation of the mutation.
func withBazelInvocation(node *BazelInvocation) bazelinvocationOption {
	return func(m *BazelInvocationMutation) {
		m.oldValue = func(context.Context) (*BazelInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BazelInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BazelInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BazelInvocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BazelInvocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BazelInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvocationID sets the "invocation_id" field.
func (m *BazelInvocationMutation) SetInvocationID(u uuid.UUID) {
	m.invocation_id = &u
}

// InvocationID returns the value of the "invocation_id" field in the mutation.
func (m *BazelInvocationMutation) InvocationID() (r uuid.UUID, exists bool) {
	v := m.invocation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvocationID returns the old "invocation_id" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldInvocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvocationID: %w", err)
	}
	return oldValue.InvocationID, nil
}

// ResetInvocationID resets all changes to the "invocation_id" field.
func (m *BazelInvocationMutation) ResetInvocationID() {
	m.invocation_id = nil
}

// SetStartedAt sets the "started_at" field.
func (m *BazelInvocationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *BazelInvocationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *BazelInvocationMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *BazelInvocationMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *BazelInvocationMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *BazelInvocationMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[bazelinvocation.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *BazelInvocationMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *BazelInvocationMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, bazelinvocation.FieldEndedAt)
}

// SetChangeNumber sets the "change_number" field.
func (m *BazelInvocationMutation) SetChangeNumber(i int32) {
	m.change_number = &i
	m.addchange_number = nil
}

// ChangeNumber returns the value of the "change_number" field in the mutation.
func (m *BazelInvocationMutation) ChangeNumber() (r int32, exists bool) {
	v := m.change_number
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeNumber returns the old "change_number" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldChangeNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeNumber: %w", err)
	}
	return oldValue.ChangeNumber, nil
}

// AddChangeNumber adds i to the "change_number" field.
func (m *BazelInvocationMutation) AddChangeNumber(i int32) {
	if m.addchange_number != nil {
		*m.addchange_number += i
	} else {
		m.addchange_number = &i
	}
}

// AddedChangeNumber returns the value that was added to the "change_number" field in this mutation.
func (m *BazelInvocationMutation) AddedChangeNumber() (r int32, exists bool) {
	v := m.addchange_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearChangeNumber clears the value of the "change_number" field.
func (m *BazelInvocationMutation) ClearChangeNumber() {
	m.change_number = nil
	m.addchange_number = nil
	m.clearedFields[bazelinvocation.FieldChangeNumber] = struct{}{}
}

// ChangeNumberCleared returns if the "change_number" field was cleared in this mutation.
func (m *BazelInvocationMutation) ChangeNumberCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldChangeNumber]
	return ok
}

// ResetChangeNumber resets all changes to the "change_number" field.
func (m *BazelInvocationMutation) ResetChangeNumber() {
	m.change_number = nil
	m.addchange_number = nil
	delete(m.clearedFields, bazelinvocation.FieldChangeNumber)
}

// SetPatchsetNumber sets the "patchset_number" field.
func (m *BazelInvocationMutation) SetPatchsetNumber(i int32) {
	m.patchset_number = &i
	m.addpatchset_number = nil
}

// PatchsetNumber returns the value of the "patchset_number" field in the mutation.
func (m *BazelInvocationMutation) PatchsetNumber() (r int32, exists bool) {
	v := m.patchset_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPatchsetNumber returns the old "patchset_number" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldPatchsetNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatchsetNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatchsetNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatchsetNumber: %w", err)
	}
	return oldValue.PatchsetNumber, nil
}

// AddPatchsetNumber adds i to the "patchset_number" field.
func (m *BazelInvocationMutation) AddPatchsetNumber(i int32) {
	if m.addpatchset_number != nil {
		*m.addpatchset_number += i
	} else {
		m.addpatchset_number = &i
	}
}

// AddedPatchsetNumber returns the value that was added to the "patchset_number" field in this mutation.
func (m *BazelInvocationMutation) AddedPatchsetNumber() (r int32, exists bool) {
	v := m.addpatchset_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearPatchsetNumber clears the value of the "patchset_number" field.
func (m *BazelInvocationMutation) ClearPatchsetNumber() {
	m.patchset_number = nil
	m.addpatchset_number = nil
	m.clearedFields[bazelinvocation.FieldPatchsetNumber] = struct{}{}
}

// PatchsetNumberCleared returns if the "patchset_number" field was cleared in this mutation.
func (m *BazelInvocationMutation) PatchsetNumberCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldPatchsetNumber]
	return ok
}

// ResetPatchsetNumber resets all changes to the "patchset_number" field.
func (m *BazelInvocationMutation) ResetPatchsetNumber() {
	m.patchset_number = nil
	m.addpatchset_number = nil
	delete(m.clearedFields, bazelinvocation.FieldPatchsetNumber)
}

// SetSummary sets the "summary" field.
func (m *BazelInvocationMutation) SetSummary(ss summary.InvocationSummary) {
	m.summary = &ss
}

// Summary returns the value of the "summary" field in the mutation.
func (m *BazelInvocationMutation) Summary() (r summary.InvocationSummary, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldSummary(ctx context.Context) (v summary.InvocationSummary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ResetSummary resets all changes to the "summary" field.
func (m *BazelInvocationMutation) ResetSummary() {
	m.summary = nil
}

// SetBepCompleted sets the "bep_completed" field.
func (m *BazelInvocationMutation) SetBepCompleted(b bool) {
	m.bep_completed = &b
}

// BepCompleted returns the value of the "bep_completed" field in the mutation.
func (m *BazelInvocationMutation) BepCompleted() (r bool, exists bool) {
	v := m.bep_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldBepCompleted returns the old "bep_completed" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldBepCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBepCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBepCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBepCompleted: %w", err)
	}
	return oldValue.BepCompleted, nil
}

// ClearBepCompleted clears the value of the "bep_completed" field.
func (m *BazelInvocationMutation) ClearBepCompleted() {
	m.bep_completed = nil
	m.clearedFields[bazelinvocation.FieldBepCompleted] = struct{}{}
}

// BepCompletedCleared returns if the "bep_completed" field was cleared in this mutation.
func (m *BazelInvocationMutation) BepCompletedCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldBepCompleted]
	return ok
}

// ResetBepCompleted resets all changes to the "bep_completed" field.
func (m *BazelInvocationMutation) ResetBepCompleted() {
	m.bep_completed = nil
	delete(m.clearedFields, bazelinvocation.FieldBepCompleted)
}

// SetStepLabel sets the "step_label" field.
func (m *BazelInvocationMutation) SetStepLabel(s string) {
	m.step_label = &s
}

// StepLabel returns the value of the "step_label" field in the mutation.
func (m *BazelInvocationMutation) StepLabel() (r string, exists bool) {
	v := m.step_label
	if v == nil {
		return
	}
	return *v, true
}

// OldStepLabel returns the old "step_label" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldStepLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepLabel: %w", err)
	}
	return oldValue.StepLabel, nil
}

// ResetStepLabel resets all changes to the "step_label" field.
func (m *BazelInvocationMutation) ResetStepLabel() {
	m.step_label = nil
}

// SetRelatedFiles sets the "related_files" field.
func (m *BazelInvocationMutation) SetRelatedFiles(value map[string]string) {
	m.related_files = &value
}

// RelatedFiles returns the value of the "related_files" field in the mutation.
func (m *BazelInvocationMutation) RelatedFiles() (r map[string]string, exists bool) {
	v := m.related_files
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedFiles returns the old "related_files" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldRelatedFiles(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedFiles: %w", err)
	}
	return oldValue.RelatedFiles, nil
}

// ResetRelatedFiles resets all changes to the "related_files" field.
func (m *BazelInvocationMutation) ResetRelatedFiles() {
	m.related_files = nil
}

// SetUserEmail sets the "user_email" field.
func (m *BazelInvocationMutation) SetUserEmail(s string) {
	m.user_email = &s
}

// UserEmail returns the value of the "user_email" field in the mutation.
func (m *BazelInvocationMutation) UserEmail() (r string, exists bool) {
	v := m.user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldUserEmail returns the old "user_email" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserEmail: %w", err)
	}
	return oldValue.UserEmail, nil
}

// ClearUserEmail clears the value of the "user_email" field.
func (m *BazelInvocationMutation) ClearUserEmail() {
	m.user_email = nil
	m.clearedFields[bazelinvocation.FieldUserEmail] = struct{}{}
}

// UserEmailCleared returns if the "user_email" field was cleared in this mutation.
func (m *BazelInvocationMutation) UserEmailCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldUserEmail]
	return ok
}

// ResetUserEmail resets all changes to the "user_email" field.
func (m *BazelInvocationMutation) ResetUserEmail() {
	m.user_email = nil
	delete(m.clearedFields, bazelinvocation.FieldUserEmail)
}

// SetUserLdap sets the "user_ldap" field.
func (m *BazelInvocationMutation) SetUserLdap(s string) {
	m.user_ldap = &s
}

// UserLdap returns the value of the "user_ldap" field in the mutation.
func (m *BazelInvocationMutation) UserLdap() (r string, exists bool) {
	v := m.user_ldap
	if v == nil {
		return
	}
	return *v, true
}

// OldUserLdap returns the old "user_ldap" field's value of the BazelInvocation entity.
// If the BazelInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationMutation) OldUserLdap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserLdap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserLdap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserLdap: %w", err)
	}
	return oldValue.UserLdap, nil
}

// ClearUserLdap clears the value of the "user_ldap" field.
func (m *BazelInvocationMutation) ClearUserLdap() {
	m.user_ldap = nil
	m.clearedFields[bazelinvocation.FieldUserLdap] = struct{}{}
}

// UserLdapCleared returns if the "user_ldap" field was cleared in this mutation.
func (m *BazelInvocationMutation) UserLdapCleared() bool {
	_, ok := m.clearedFields[bazelinvocation.FieldUserLdap]
	return ok
}

// ResetUserLdap resets all changes to the "user_ldap" field.
func (m *BazelInvocationMutation) ResetUserLdap() {
	m.user_ldap = nil
	delete(m.clearedFields, bazelinvocation.FieldUserLdap)
}

// SetEventFileID sets the "event_file" edge to the EventFile entity by id.
func (m *BazelInvocationMutation) SetEventFileID(id int) {
	m.event_file = &id
}

// ClearEventFile clears the "event_file" edge to the EventFile entity.
func (m *BazelInvocationMutation) ClearEventFile() {
	m.clearedevent_file = true
}

// EventFileCleared reports if the "event_file" edge to the EventFile entity was cleared.
func (m *BazelInvocationMutation) EventFileCleared() bool {
	return m.clearedevent_file
}

// EventFileID returns the "event_file" edge ID in the mutation.
func (m *BazelInvocationMutation) EventFileID() (id int, exists bool) {
	if m.event_file != nil {
		return *m.event_file, true
	}
	return
}

// EventFileIDs returns the "event_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventFileID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) EventFileIDs() (ids []int) {
	if id := m.event_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEventFile resets all changes to the "event_file" edge.
func (m *BazelInvocationMutation) ResetEventFile() {
	m.event_file = nil
	m.clearedevent_file = false
}

// SetBuildID sets the "build" edge to the Build entity by id.
func (m *BazelInvocationMutation) SetBuildID(id int) {
	m.build = &id
}

// ClearBuild clears the "build" edge to the Build entity.
func (m *BazelInvocationMutation) ClearBuild() {
	m.clearedbuild = true
}

// BuildCleared reports if the "build" edge to the Build entity was cleared.
func (m *BazelInvocationMutation) BuildCleared() bool {
	return m.clearedbuild
}

// BuildID returns the "build" edge ID in the mutation.
func (m *BazelInvocationMutation) BuildID() (id int, exists bool) {
	if m.build != nil {
		return *m.build, true
	}
	return
}

// BuildIDs returns the "build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationMutation) BuildIDs() (ids []int) {
	if id := m.build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "build" edge.
func (m *BazelInvocationMutation) ResetBuild() {
	m.build = nil
	m.clearedbuild = false
}

// AddProblemIDs adds the "problems" edge to the BazelInvocationProblem entity by ids.
func (m *BazelInvocationMutation) AddProblemIDs(ids ...int) {
	if m.problems == nil {
		m.problems = make(map[int]struct{})
	}
	for i := range ids {
		m.problems[ids[i]] = struct{}{}
	}
}

// ClearProblems clears the "problems" edge to the BazelInvocationProblem entity.
func (m *BazelInvocationMutation) ClearProblems() {
	m.clearedproblems = true
}

// ProblemsCleared reports if the "problems" edge to the BazelInvocationProblem entity was cleared.
func (m *BazelInvocationMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// RemoveProblemIDs removes the "problems" edge to the BazelInvocationProblem entity by IDs.
func (m *BazelInvocationMutation) RemoveProblemIDs(ids ...int) {
	if m.removedproblems == nil {
		m.removedproblems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.problems, ids[i])
		m.removedproblems[ids[i]] = struct{}{}
	}
}

// RemovedProblems returns the removed IDs of the "problems" edge to the BazelInvocationProblem entity.
func (m *BazelInvocationMutation) RemovedProblemsIDs() (ids []int) {
	for id := range m.removedproblems {
		ids = append(ids, id)
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
func (m *BazelInvocationMutation) ProblemsIDs() (ids []int) {
	for id := range m.problems {
		ids = append(ids, id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *BazelInvocationMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
	m.removedproblems = nil
}

// Where appends a list predicates to the BazelInvocationMutation builder.
func (m *BazelInvocationMutation) Where(ps ...predicate.BazelInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BazelInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BazelInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BazelInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BazelInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BazelInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BazelInvocation).
func (m *BazelInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BazelInvocationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.invocation_id != nil {
		fields = append(fields, bazelinvocation.FieldInvocationID)
	}
	if m.started_at != nil {
		fields = append(fields, bazelinvocation.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, bazelinvocation.FieldEndedAt)
	}
	if m.change_number != nil {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.patchset_number != nil {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	if m.summary != nil {
		fields = append(fields, bazelinvocation.FieldSummary)
	}
	if m.bep_completed != nil {
		fields = append(fields, bazelinvocation.FieldBepCompleted)
	}
	if m.step_label != nil {
		fields = append(fields, bazelinvocation.FieldStepLabel)
	}
	if m.related_files != nil {
		fields = append(fields, bazelinvocation.FieldRelatedFiles)
	}
	if m.user_email != nil {
		fields = append(fields, bazelinvocation.FieldUserEmail)
	}
	if m.user_ldap != nil {
		fields = append(fields, bazelinvocation.FieldUserLdap)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BazelInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bazelinvocation.FieldInvocationID:
		return m.InvocationID()
	case bazelinvocation.FieldStartedAt:
		return m.StartedAt()
	case bazelinvocation.FieldEndedAt:
		return m.EndedAt()
	case bazelinvocation.FieldChangeNumber:
		return m.ChangeNumber()
	case bazelinvocation.FieldPatchsetNumber:
		return m.PatchsetNumber()
	case bazelinvocation.FieldSummary:
		return m.Summary()
	case bazelinvocation.FieldBepCompleted:
		return m.BepCompleted()
	case bazelinvocation.FieldStepLabel:
		return m.StepLabel()
	case bazelinvocation.FieldRelatedFiles:
		return m.RelatedFiles()
	case bazelinvocation.FieldUserEmail:
		return m.UserEmail()
	case bazelinvocation.FieldUserLdap:
		return m.UserLdap()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BazelInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bazelinvocation.FieldInvocationID:
		return m.OldInvocationID(ctx)
	case bazelinvocation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case bazelinvocation.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case bazelinvocation.FieldChangeNumber:
		return m.OldChangeNumber(ctx)
	case bazelinvocation.FieldPatchsetNumber:
		return m.OldPatchsetNumber(ctx)
	case bazelinvocation.FieldSummary:
		return m.OldSummary(ctx)
	case bazelinvocation.FieldBepCompleted:
		return m.OldBepCompleted(ctx)
	case bazelinvocation.FieldStepLabel:
		return m.OldStepLabel(ctx)
	case bazelinvocation.FieldRelatedFiles:
		return m.OldRelatedFiles(ctx)
	case bazelinvocation.FieldUserEmail:
		return m.OldUserEmail(ctx)
	case bazelinvocation.FieldUserLdap:
		return m.OldUserLdap(ctx)
	}
	return nil, fmt.Errorf("unknown BazelInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bazelinvocation.FieldInvocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvocationID(v)
		return nil
	case bazelinvocation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case bazelinvocation.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case bazelinvocation.FieldChangeNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeNumber(v)
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatchsetNumber(v)
		return nil
	case bazelinvocation.FieldSummary:
		v, ok := value.(summary.InvocationSummary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case bazelinvocation.FieldBepCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBepCompleted(v)
		return nil
	case bazelinvocation.FieldStepLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepLabel(v)
		return nil
	case bazelinvocation.FieldRelatedFiles:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedFiles(v)
		return nil
	case bazelinvocation.FieldUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserEmail(v)
		return nil
	case bazelinvocation.FieldUserLdap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserLdap(v)
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BazelInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addchange_number != nil {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.addpatchset_number != nil {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BazelInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bazelinvocation.FieldChangeNumber:
		return m.AddedChangeNumber()
	case bazelinvocation.FieldPatchsetNumber:
		return m.AddedPatchsetNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bazelinvocation.FieldChangeNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChangeNumber(v)
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatchsetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BazelInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bazelinvocation.FieldEndedAt) {
		fields = append(fields, bazelinvocation.FieldEndedAt)
	}
	if m.FieldCleared(bazelinvocation.FieldChangeNumber) {
		fields = append(fields, bazelinvocation.FieldChangeNumber)
	}
	if m.FieldCleared(bazelinvocation.FieldPatchsetNumber) {
		fields = append(fields, bazelinvocation.FieldPatchsetNumber)
	}
	if m.FieldCleared(bazelinvocation.FieldBepCompleted) {
		fields = append(fields, bazelinvocation.FieldBepCompleted)
	}
	if m.FieldCleared(bazelinvocation.FieldUserEmail) {
		fields = append(fields, bazelinvocation.FieldUserEmail)
	}
	if m.FieldCleared(bazelinvocation.FieldUserLdap) {
		fields = append(fields, bazelinvocation.FieldUserLdap)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BazelInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BazelInvocationMutation) ClearField(name string) error {
	switch name {
	case bazelinvocation.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case bazelinvocation.FieldChangeNumber:
		m.ClearChangeNumber()
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		m.ClearPatchsetNumber()
		return nil
	case bazelinvocation.FieldBepCompleted:
		m.ClearBepCompleted()
		return nil
	case bazelinvocation.FieldUserEmail:
		m.ClearUserEmail()
		return nil
	case bazelinvocation.FieldUserLdap:
		m.ClearUserLdap()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BazelInvocationMutation) ResetField(name string) error {
	switch name {
	case bazelinvocation.FieldInvocationID:
		m.ResetInvocationID()
		return nil
	case bazelinvocation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case bazelinvocation.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case bazelinvocation.FieldChangeNumber:
		m.ResetChangeNumber()
		return nil
	case bazelinvocation.FieldPatchsetNumber:
		m.ResetPatchsetNumber()
		return nil
	case bazelinvocation.FieldSummary:
		m.ResetSummary()
		return nil
	case bazelinvocation.FieldBepCompleted:
		m.ResetBepCompleted()
		return nil
	case bazelinvocation.FieldStepLabel:
		m.ResetStepLabel()
		return nil
	case bazelinvocation.FieldRelatedFiles:
		m.ResetRelatedFiles()
		return nil
	case bazelinvocation.FieldUserEmail:
		m.ResetUserEmail()
		return nil
	case bazelinvocation.FieldUserLdap:
		m.ResetUserLdap()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BazelInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.event_file != nil {
		edges = append(edges, bazelinvocation.EdgeEventFile)
	}
	if m.build != nil {
		edges = append(edges, bazelinvocation.EdgeBuild)
	}
	if m.problems != nil {
		edges = append(edges, bazelinvocation.EdgeProblems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BazelInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bazelinvocation.EdgeEventFile:
		if id := m.event_file; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeBuild:
		if id := m.build; id != nil {
			return []ent.Value{*id}
		}
	case bazelinvocation.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.problems))
		for id := range m.problems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BazelInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproblems != nil {
		edges = append(edges, bazelinvocation.EdgeProblems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BazelInvocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bazelinvocation.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.removedproblems))
		for id := range m.removedproblems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BazelInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedevent_file {
		edges = append(edges, bazelinvocation.EdgeEventFile)
	}
	if m.clearedbuild {
		edges = append(edges, bazelinvocation.EdgeBuild)
	}
	if m.clearedproblems {
		edges = append(edges, bazelinvocation.EdgeProblems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BazelInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case bazelinvocation.EdgeEventFile:
		return m.clearedevent_file
	case bazelinvocation.EdgeBuild:
		return m.clearedbuild
	case bazelinvocation.EdgeProblems:
		return m.clearedproblems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BazelInvocationMutation) ClearEdge(name string) error {
	switch name {
	case bazelinvocation.EdgeEventFile:
		m.ClearEventFile()
		return nil
	case bazelinvocation.EdgeBuild:
		m.ClearBuild()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BazelInvocationMutation) ResetEdge(name string) error {
	switch name {
	case bazelinvocation.EdgeEventFile:
		m.ResetEventFile()
		return nil
	case bazelinvocation.EdgeBuild:
		m.ResetBuild()
		return nil
	case bazelinvocation.EdgeProblems:
		m.ResetProblems()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocation edge %s", name)
}

// BazelInvocationProblemMutation represents an operation that mutates the BazelInvocationProblem nodes in the graph.
type BazelInvocationProblemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	problem_type            *string
	label                   *string
	bep_events              *json.RawMessage
	appendbep_events        json.RawMessage
	clearedFields           map[string]struct{}
	bazel_invocation        *int
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*BazelInvocationProblem, error)
	predicates              []predicate.BazelInvocationProblem
}

var _ ent.Mutation = (*BazelInvocationProblemMutation)(nil)

// bazelinvocationproblemOption allows management of the mutation configuration using functional options.
type bazelinvocationproblemOption func(*BazelInvocationProblemMutation)

// newBazelInvocationProblemMutation creates new mutation for the BazelInvocationProblem entity.
func newBazelInvocationProblemMutation(c config, op Op, opts ...bazelinvocationproblemOption) *BazelInvocationProblemMutation {
	m := &BazelInvocationProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeBazelInvocationProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBazelInvocationProblemID sets the ID field of the mutation.
func withBazelInvocationProblemID(id int) bazelinvocationproblemOption {
	return func(m *BazelInvocationProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *BazelInvocationProblem
		)
		m.oldValue = func(ctx context.Context) (*BazelInvocationProblem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BazelInvocationProblem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBazelInvocationProblem sets the old BazelInvocationProblem of the mutation.
func withBazelInvocationProblem(node *BazelInvocationProblem) bazelinvocationproblemOption {
	return func(m *BazelInvocationProblemMutation) {
		m.oldValue = func(context.Context) (*BazelInvocationProblem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BazelInvocationProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BazelInvocationProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BazelInvocationProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BazelInvocationProblemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BazelInvocationProblem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProblemType sets the "problem_type" field.
func (m *BazelInvocationProblemMutation) SetProblemType(s string) {
	m.problem_type = &s
}

// ProblemType returns the value of the "problem_type" field in the mutation.
func (m *BazelInvocationProblemMutation) ProblemType() (r string, exists bool) {
	v := m.problem_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProblemType returns the old "problem_type" field's value of the BazelInvocationProblem entity.
// If the BazelInvocationProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationProblemMutation) OldProblemType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProblemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProblemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProblemType: %w", err)
	}
	return oldValue.ProblemType, nil
}

// ResetProblemType resets all changes to the "problem_type" field.
func (m *BazelInvocationProblemMutation) ResetProblemType() {
	m.problem_type = nil
}

// SetLabel sets the "label" field.
func (m *BazelInvocationProblemMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *BazelInvocationProblemMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the BazelInvocationProblem entity.
// If the BazelInvocationProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationProblemMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *BazelInvocationProblemMutation) ResetLabel() {
	m.label = nil
}

// SetBepEvents sets the "bep_events" field.
func (m *BazelInvocationProblemMutation) SetBepEvents(jm json.RawMessage) {
	m.bep_events = &jm
	m.appendbep_events = nil
}

// BepEvents returns the value of the "bep_events" field in the mutation.
func (m *BazelInvocationProblemMutation) BepEvents() (r json.RawMessage, exists bool) {
	v := m.bep_events
	if v == nil {
		return
	}
	return *v, true
}

// OldBepEvents returns the old "bep_events" field's value of the BazelInvocationProblem entity.
// If the BazelInvocationProblem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BazelInvocationProblemMutation) OldBepEvents(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBepEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBepEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBepEvents: %w", err)
	}
	return oldValue.BepEvents, nil
}

// AppendBepEvents adds jm to the "bep_events" field.
func (m *BazelInvocationProblemMutation) AppendBepEvents(jm json.RawMessage) {
	m.appendbep_events = append(m.appendbep_events, jm...)
}

// AppendedBepEvents returns the list of values that were appended to the "bep_events" field in this mutation.
func (m *BazelInvocationProblemMutation) AppendedBepEvents() (json.RawMessage, bool) {
	if len(m.appendbep_events) == 0 {
		return nil, false
	}
	return m.appendbep_events, true
}

// ResetBepEvents resets all changes to the "bep_events" field.
func (m *BazelInvocationProblemMutation) ResetBepEvents() {
	m.bep_events = nil
	m.appendbep_events = nil
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *BazelInvocationProblemMutation) SetBazelInvocationID(id int) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *BazelInvocationProblemMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *BazelInvocationProblemMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *BazelInvocationProblemMutation) BazelInvocationID() (id int, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *BazelInvocationProblemMutation) BazelInvocationIDs() (ids []int) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *BazelInvocationProblemMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the BazelInvocationProblemMutation builder.
func (m *BazelInvocationProblemMutation) Where(ps ...predicate.BazelInvocationProblem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BazelInvocationProblemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BazelInvocationProblemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BazelInvocationProblem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BazelInvocationProblemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BazelInvocationProblemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BazelInvocationProblem).
func (m *BazelInvocationProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BazelInvocationProblemMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.problem_type != nil {
		fields = append(fields, bazelinvocationproblem.FieldProblemType)
	}
	if m.label != nil {
		fields = append(fields, bazelinvocationproblem.FieldLabel)
	}
	if m.bep_events != nil {
		fields = append(fields, bazelinvocationproblem.FieldBepEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BazelInvocationProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bazelinvocationproblem.FieldProblemType:
		return m.ProblemType()
	case bazelinvocationproblem.FieldLabel:
		return m.Label()
	case bazelinvocationproblem.FieldBepEvents:
		return m.BepEvents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BazelInvocationProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bazelinvocationproblem.FieldProblemType:
		return m.OldProblemType(ctx)
	case bazelinvocationproblem.FieldLabel:
		return m.OldLabel(ctx)
	case bazelinvocationproblem.FieldBepEvents:
		return m.OldBepEvents(ctx)
	}
	return nil, fmt.Errorf("unknown BazelInvocationProblem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bazelinvocationproblem.FieldProblemType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProblemType(v)
		return nil
	case bazelinvocationproblem.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case bazelinvocationproblem.FieldBepEvents:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBepEvents(v)
		return nil
	}
	return fmt.Errorf("unknown BazelInvocationProblem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BazelInvocationProblemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BazelInvocationProblemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BazelInvocationProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BazelInvocationProblem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BazelInvocationProblemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BazelInvocationProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BazelInvocationProblemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BazelInvocationProblem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BazelInvocationProblemMutation) ResetField(name string) error {
	switch name {
	case bazelinvocationproblem.FieldProblemType:
		m.ResetProblemType()
		return nil
	case bazelinvocationproblem.FieldLabel:
		m.ResetLabel()
		return nil
	case bazelinvocationproblem.FieldBepEvents:
		m.ResetBepEvents()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocationProblem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BazelInvocationProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, bazelinvocationproblem.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BazelInvocationProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bazelinvocationproblem.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BazelInvocationProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BazelInvocationProblemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BazelInvocationProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, bazelinvocationproblem.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BazelInvocationProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case bazelinvocationproblem.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BazelInvocationProblemMutation) ClearEdge(name string) error {
	switch name {
	case bazelinvocationproblem.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocationProblem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BazelInvocationProblemMutation) ResetEdge(name string) error {
	switch name {
	case bazelinvocationproblem.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown BazelInvocationProblem edge %s", name)
}

// BlobMutation represents an operation that mutates the Blob nodes in the graph.
type BlobMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uri              *string
	size_bytes       *int64
	addsize_bytes    *int64
	archiving_status *blob.ArchivingStatus
	reason           *string
	archive_url      *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Blob, error)
	predicates       []predicate.Blob
}

var _ ent.Mutation = (*BlobMutation)(nil)

// blobOption allows management of the mutation configuration using functional options.
type blobOption func(*BlobMutation)

// newBlobMutation creates new mutation for the Blob entity.
func newBlobMutation(c config, op Op, opts ...blobOption) *BlobMutation {
	m := &BlobMutation{
		config:        c,
		op:            op,
		typ:           TypeBlob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlobID sets the ID field of the mutation.
func withBlobID(id int) blobOption {
	return func(m *BlobMutation) {
		var (
			err   error
			once  sync.Once
			value *Blob
		)
		m.oldValue = func(ctx context.Context) (*Blob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlob sets the old Blob of the mutation.
func withBlob(node *Blob) blobOption {
	return func(m *BlobMutation) {
		m.oldValue = func(context.Context) (*Blob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURI sets the "uri" field.
func (m *BlobMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *BlobMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the Blob entity.
// If the Blob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ResetURI resets all changes to the "uri" field.
func (m *BlobMutation) ResetURI() {
	m.uri = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *BlobMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *BlobMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the Blob entity.
// If the Blob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *BlobMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *BlobMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *BlobMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[blob.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *BlobMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[blob.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *BlobMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, blob.FieldSizeBytes)
}

// SetArchivingStatus sets the "archiving_status" field.
func (m *BlobMutation) SetArchivingStatus(bs blob.ArchivingStatus) {
	m.archiving_status = &bs
}

// ArchivingStatus returns the value of the "archiving_status" field in the mutation.
func (m *BlobMutation) ArchivingStatus() (r blob.ArchivingStatus, exists bool) {
	v := m.archiving_status
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivingStatus returns the old "archiving_status" field's value of the Blob entity.
// If the Blob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobMutation) OldArchivingStatus(ctx context.Context) (v blob.ArchivingStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivingStatus: %w", err)
	}
	return oldValue.ArchivingStatus, nil
}

// ResetArchivingStatus resets all changes to the "archiving_status" field.
func (m *BlobMutation) ResetArchivingStatus() {
	m.archiving_status = nil
}

// SetReason sets the "reason" field.
func (m *BlobMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *BlobMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Blob entity.
// If the Blob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *BlobMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[blob.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *BlobMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[blob.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *BlobMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, blob.FieldReason)
}

// SetArchiveURL sets the "archive_url" field.
func (m *BlobMutation) SetArchiveURL(s string) {
	m.archive_url = &s
}

// ArchiveURL returns the value of the "archive_url" field in the mutation.
func (m *BlobMutation) ArchiveURL() (r string, exists bool) {
	v := m.archive_url
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveURL returns the old "archive_url" field's value of the Blob entity.
// If the Blob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobMutation) OldArchiveURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveURL: %w", err)
	}
	return oldValue.ArchiveURL, nil
}

// ClearArchiveURL clears the value of the "archive_url" field.
func (m *BlobMutation) ClearArchiveURL() {
	m.archive_url = nil
	m.clearedFields[blob.FieldArchiveURL] = struct{}{}
}

// ArchiveURLCleared returns if the "archive_url" field was cleared in this mutation.
func (m *BlobMutation) ArchiveURLCleared() bool {
	_, ok := m.clearedFields[blob.FieldArchiveURL]
	return ok
}

// ResetArchiveURL resets all changes to the "archive_url" field.
func (m *BlobMutation) ResetArchiveURL() {
	m.archive_url = nil
	delete(m.clearedFields, blob.FieldArchiveURL)
}

// Where appends a list predicates to the BlobMutation builder.
func (m *BlobMutation) Where(ps ...predicate.Blob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blob).
func (m *BlobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlobMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.uri != nil {
		fields = append(fields, blob.FieldURI)
	}
	if m.size_bytes != nil {
		fields = append(fields, blob.FieldSizeBytes)
	}
	if m.archiving_status != nil {
		fields = append(fields, blob.FieldArchivingStatus)
	}
	if m.reason != nil {
		fields = append(fields, blob.FieldReason)
	}
	if m.archive_url != nil {
		fields = append(fields, blob.FieldArchiveURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blob.FieldURI:
		return m.URI()
	case blob.FieldSizeBytes:
		return m.SizeBytes()
	case blob.FieldArchivingStatus:
		return m.ArchivingStatus()
	case blob.FieldReason:
		return m.Reason()
	case blob.FieldArchiveURL:
		return m.ArchiveURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blob.FieldURI:
		return m.OldURI(ctx)
	case blob.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case blob.FieldArchivingStatus:
		return m.OldArchivingStatus(ctx)
	case blob.FieldReason:
		return m.OldReason(ctx)
	case blob.FieldArchiveURL:
		return m.OldArchiveURL(ctx)
	}
	return nil, fmt.Errorf("unknown Blob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blob.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case blob.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case blob.FieldArchivingStatus:
		v, ok := value.(blob.ArchivingStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivingStatus(v)
		return nil
	case blob.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case blob.FieldArchiveURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveURL(v)
		return nil
	}
	return fmt.Errorf("unknown Blob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlobMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, blob.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blob.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blob.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown Blob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blob.FieldSizeBytes) {
		fields = append(fields, blob.FieldSizeBytes)
	}
	if m.FieldCleared(blob.FieldReason) {
		fields = append(fields, blob.FieldReason)
	}
	if m.FieldCleared(blob.FieldArchiveURL) {
		fields = append(fields, blob.FieldArchiveURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlobMutation) ClearField(name string) error {
	switch name {
	case blob.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case blob.FieldReason:
		m.ClearReason()
		return nil
	case blob.FieldArchiveURL:
		m.ClearArchiveURL()
		return nil
	}
	return fmt.Errorf("unknown Blob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlobMutation) ResetField(name string) error {
	switch name {
	case blob.FieldURI:
		m.ResetURI()
		return nil
	case blob.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case blob.FieldArchivingStatus:
		m.ResetArchivingStatus()
		return nil
	case blob.FieldReason:
		m.ResetReason()
		return nil
	case blob.FieldArchiveURL:
		m.ResetArchiveURL()
		return nil
	}
	return fmt.Errorf("unknown Blob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blob edge %s", name)
}

// BuildMutation represents an operation that mutates the Build nodes in the graph.
type BuildMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	build_url          *string
	build_uuid         *uuid.UUID
	env                *map[string]string
	clearedFields      map[string]struct{}
	invocations        map[int]struct{}
	removedinvocations map[int]struct{}
	clearedinvocations bool
	done               bool
	oldValue           func(context.Context) (*Build, error)
	predicates         []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows management of the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for the Build entity.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the ID field of the mutation.
func withBuildID(id int) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Build.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildURL sets the "build_url" field.
func (m *BuildMutation) SetBuildURL(s string) {
	m.build_url = &s
}

// BuildURL returns the value of the "build_url" field in the mutation.
func (m *BuildMutation) BuildURL() (r string, exists bool) {
	v := m.build_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildURL returns the old "build_url" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldBuildURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildURL: %w", err)
	}
	return oldValue.BuildURL, nil
}

// ResetBuildURL resets all changes to the "build_url" field.
func (m *BuildMutation) ResetBuildURL() {
	m.build_url = nil
}

// SetBuildUUID sets the "build_uuid" field.
func (m *BuildMutation) SetBuildUUID(u uuid.UUID) {
	m.build_uuid = &u
}

// BuildUUID returns the value of the "build_uuid" field in the mutation.
func (m *BuildMutation) BuildUUID() (r uuid.UUID, exists bool) {
	v := m.build_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildUUID returns the old "build_uuid" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldBuildUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildUUID: %w", err)
	}
	return oldValue.BuildUUID, nil
}

// ResetBuildUUID resets all changes to the "build_uuid" field.
func (m *BuildMutation) ResetBuildUUID() {
	m.build_uuid = nil
}

// SetEnv sets the "env" field.
func (m *BuildMutation) SetEnv(value map[string]string) {
	m.env = &value
}

// Env returns the value of the "env" field in the mutation.
func (m *BuildMutation) Env() (r map[string]string, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnv returns the old "env" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldEnv(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnv: %w", err)
	}
	return oldValue.Env, nil
}

// ResetEnv resets all changes to the "env" field.
func (m *BuildMutation) ResetEnv() {
	m.env = nil
}

// AddInvocationIDs adds the "invocations" edge to the BazelInvocation entity by ids.
func (m *BuildMutation) AddInvocationIDs(ids ...int) {
	if m.invocations == nil {
		m.invocations = make(map[int]struct{})
	}
	for i := range ids {
		m.invocations[ids[i]] = struct{}{}
	}
}

// ClearInvocations clears the "invocations" edge to the BazelInvocation entity.
func (m *BuildMutation) ClearInvocations() {
	m.clearedinvocations = true
}

// InvocationsCleared reports if the "invocations" edge to the BazelInvocation entity was cleared.
func (m *BuildMutation) InvocationsCleared() bool {
	return m.clearedinvocations
}

// RemoveInvocationIDs removes the "invocations" edge to the BazelInvocation entity by IDs.
func (m *BuildMutation) RemoveInvocationIDs(ids ...int) {
	if m.removedinvocations == nil {
		m.removedinvocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invocations, ids[i])
		m.removedinvocations[ids[i]] = struct{}{}
	}
}

// RemovedInvocations returns the removed IDs of the "invocations" edge to the BazelInvocation entity.
func (m *BuildMutation) RemovedInvocationsIDs() (ids []int) {
	for id := range m.removedinvocations {
		ids = append(ids, id)
	}
	return
}

// InvocationsIDs returns the "invocations" edge IDs in the mutation.
func (m *BuildMutation) InvocationsIDs() (ids []int) {
	for id := range m.invocations {
		ids = append(ids, id)
	}
	return
}

// ResetInvocations resets all changes to the "invocations" edge.
func (m *BuildMutation) ResetInvocations() {
	m.invocations = nil
	m.clearedinvocations = false
	m.removedinvocations = nil
}

// Where appends a list predicates to the BuildMutation builder.
func (m *BuildMutation) Where(ps ...predicate.Build) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Build, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.build_url != nil {
		fields = append(fields, build.FieldBuildURL)
	}
	if m.build_uuid != nil {
		fields = append(fields, build.FieldBuildUUID)
	}
	if m.env != nil {
		fields = append(fields, build.FieldEnv)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldBuildURL:
		return m.BuildURL()
	case build.FieldBuildUUID:
		return m.BuildUUID()
	case build.FieldEnv:
		return m.Env()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldBuildURL:
		return m.OldBuildURL(ctx)
	case build.FieldBuildUUID:
		return m.OldBuildUUID(ctx)
	case build.FieldEnv:
		return m.OldEnv(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldBuildURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildURL(v)
		return nil
	case build.FieldBuildUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildUUID(v)
		return nil
	case build.FieldEnv:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnv(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldBuildURL:
		m.ResetBuildURL()
		return nil
	case build.FieldBuildUUID:
		m.ResetBuildUUID()
		return nil
	case build.FieldEnv:
		m.ResetEnv()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.invocations != nil {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeInvocations:
		ids := make([]ent.Value, 0, len(m.invocations))
		for id := range m.invocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinvocations != nil {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeInvocations:
		ids := make([]ent.Value, 0, len(m.removedinvocations))
		for id := range m.removedinvocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinvocations {
		edges = append(edges, build.EdgeInvocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeInvocations:
		return m.clearedinvocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeInvocations:
		m.ResetInvocations()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// EventFileMutation represents an operation that mutates the EventFile nodes in the graph.
type EventFileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	url                     *string
	mod_time                *time.Time
	protocol                *string
	mime_type               *string
	status                  *string
	reason                  *string
	clearedFields           map[string]struct{}
	bazel_invocation        *int
	clearedbazel_invocation bool
	done                    bool
	oldValue                func(context.Context) (*EventFile, error)
	predicates              []predicate.EventFile
}

var _ ent.Mutation = (*EventFileMutation)(nil)

// eventfileOption allows management of the mutation configuration using functional options.
type eventfileOption func(*EventFileMutation)

// newEventFileMutation creates new mutation for the EventFile entity.
func newEventFileMutation(c config, op Op, opts ...eventfileOption) *EventFileMutation {
	m := &EventFileMutation{
		config:        c,
		op:            op,
		typ:           TypeEventFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventFileID sets the ID field of the mutation.
func withEventFileID(id int) eventfileOption {
	return func(m *EventFileMutation) {
		var (
			err   error
			once  sync.Once
			value *EventFile
		)
		m.oldValue = func(ctx context.Context) (*EventFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventFile sets the old EventFile of the mutation.
func withEventFile(node *EventFile) eventfileOption {
	return func(m *EventFileMutation) {
		m.oldValue = func(context.Context) (*EventFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *EventFileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EventFileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *EventFileMutation) ResetURL() {
	m.url = nil
}

// SetModTime sets the "mod_time" field.
func (m *EventFileMutation) SetModTime(t time.Time) {
	m.mod_time = &t
}

// ModTime returns the value of the "mod_time" field in the mutation.
func (m *EventFileMutation) ModTime() (r time.Time, exists bool) {
	v := m.mod_time
	if v == nil {
		return
	}
	return *v, true
}

// OldModTime returns the old "mod_time" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldModTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModTime: %w", err)
	}
	return oldValue.ModTime, nil
}

// ResetModTime resets all changes to the "mod_time" field.
func (m *EventFileMutation) ResetModTime() {
	m.mod_time = nil
}

// SetProtocol sets the "protocol" field.
func (m *EventFileMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *EventFileMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *EventFileMutation) ResetProtocol() {
	m.protocol = nil
}

// SetMimeType sets the "mime_type" field.
func (m *EventFileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *EventFileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *EventFileMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetStatus sets the "status" field.
func (m *EventFileMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EventFileMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventFileMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *EventFileMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *EventFileMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the EventFile entity.
// If the EventFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventFileMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *EventFileMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[eventfile.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *EventFileMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[eventfile.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *EventFileMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, eventfile.FieldReason)
}

// SetBazelInvocationID sets the "bazel_invocation" edge to the BazelInvocation entity by id.
func (m *EventFileMutation) SetBazelInvocationID(id int) {
	m.bazel_invocation = &id
}

// ClearBazelInvocation clears the "bazel_invocation" edge to the BazelInvocation entity.
func (m *EventFileMutation) ClearBazelInvocation() {
	m.clearedbazel_invocation = true
}

// BazelInvocationCleared reports if the "bazel_invocation" edge to the BazelInvocation entity was cleared.
func (m *EventFileMutation) BazelInvocationCleared() bool {
	return m.clearedbazel_invocation
}

// BazelInvocationID returns the "bazel_invocation" edge ID in the mutation.
func (m *EventFileMutation) BazelInvocationID() (id int, exists bool) {
	if m.bazel_invocation != nil {
		return *m.bazel_invocation, true
	}
	return
}

// BazelInvocationIDs returns the "bazel_invocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BazelInvocationID instead. It exists only for internal usage by the builders.
func (m *EventFileMutation) BazelInvocationIDs() (ids []int) {
	if id := m.bazel_invocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBazelInvocation resets all changes to the "bazel_invocation" edge.
func (m *EventFileMutation) ResetBazelInvocation() {
	m.bazel_invocation = nil
	m.clearedbazel_invocation = false
}

// Where appends a list predicates to the EventFileMutation builder.
func (m *EventFileMutation) Where(ps ...predicate.EventFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventFile).
func (m *EventFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventFileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.url != nil {
		fields = append(fields, eventfile.FieldURL)
	}
	if m.mod_time != nil {
		fields = append(fields, eventfile.FieldModTime)
	}
	if m.protocol != nil {
		fields = append(fields, eventfile.FieldProtocol)
	}
	if m.mime_type != nil {
		fields = append(fields, eventfile.FieldMimeType)
	}
	if m.status != nil {
		fields = append(fields, eventfile.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, eventfile.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventfile.FieldURL:
		return m.URL()
	case eventfile.FieldModTime:
		return m.ModTime()
	case eventfile.FieldProtocol:
		return m.Protocol()
	case eventfile.FieldMimeType:
		return m.MimeType()
	case eventfile.FieldStatus:
		return m.Status()
	case eventfile.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventfile.FieldURL:
		return m.OldURL(ctx)
	case eventfile.FieldModTime:
		return m.OldModTime(ctx)
	case eventfile.FieldProtocol:
		return m.OldProtocol(ctx)
	case eventfile.FieldMimeType:
		return m.OldMimeType(ctx)
	case eventfile.FieldStatus:
		return m.OldStatus(ctx)
	case eventfile.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown EventFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventfile.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case eventfile.FieldModTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModTime(v)
		return nil
	case eventfile.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case eventfile.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case eventfile.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case eventfile.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown EventFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventfile.FieldReason) {
		fields = append(fields, eventfile.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventFileMutation) ClearField(name string) error {
	switch name {
	case eventfile.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown EventFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventFileMutation) ResetField(name string) error {
	switch name {
	case eventfile.FieldURL:
		m.ResetURL()
		return nil
	case eventfile.FieldModTime:
		m.ResetModTime()
		return nil
	case eventfile.FieldProtocol:
		m.ResetProtocol()
		return nil
	case eventfile.FieldMimeType:
		m.ResetMimeType()
		return nil
	case eventfile.FieldStatus:
		m.ResetStatus()
		return nil
	case eventfile.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown EventFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bazel_invocation != nil {
		edges = append(edges, eventfile.EdgeBazelInvocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventfile.EdgeBazelInvocation:
		if id := m.bazel_invocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbazel_invocation {
		edges = append(edges, eventfile.EdgeBazelInvocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventFileMutation) EdgeCleared(name string) bool {
	switch name {
	case eventfile.EdgeBazelInvocation:
		return m.clearedbazel_invocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventFileMutation) ClearEdge(name string) error {
	switch name {
	case eventfile.EdgeBazelInvocation:
		m.ClearBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown EventFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventFileMutation) ResetEdge(name string) error {
	switch name {
	case eventfile.EdgeBazelInvocation:
		m.ResetBazelInvocation()
		return nil
	}
	return fmt.Errorf("unknown EventFile edge %s", name)
}
